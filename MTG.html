<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple MTG Deck Builder (w/ Play Area)</title>
    <style>
      /* --- Base Styles (mostly unchanged) --- */
      body {
        font-family: sans-serif;
        display: grid;
        grid-template-columns: 1fr 2fr;
        grid-template-rows: auto auto auto 1fr; /* Added row for test area */
        gap: 20px;
        max-width: 1300px;
        margin: 20px auto;
        padding: 15px;
        background-color: #f0f2f5;
      }

      h1 {
        text-align: center;
        color: #333;
        grid-column: 1 / -1;
        grid-row: 1 / 2;
        margin-bottom: 15px;
      }
      .search-section h2,
      .deck-section h2,
      .actions-section h2,
      .test-hand-section h2 {
        text-align: center;
        color: #333;
        margin-bottom: 15px;
      }
      h3 {
        margin-top: 0;
        margin-bottom: 10px;
        color: #444;
        font-size: 1em; /* Consistent H3 size */
        padding: 0 5px;
      }
      h4 {
        /* Style for sub-zone headings */
        margin: 5px 0;
        font-size: 0.9em;
        color: #555;
        text-align: center;
        border-bottom: 1px solid #eee;
        padding-bottom: 3px;
      }

      .search-section,
      .deck-section,
      .actions-section,
      .test-hand-section {
        background-color: #fff;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        display: flex;
        flex-direction: column;
      }

      /* --- Grid Placement (Unchanged) --- */
      .search-section {
        grid-column: 1 / 2;
        grid-row: 2 / 3;
        position: relative;
      }
      .actions-section {
        grid-column: 1 / 2;
        grid-row: 3 / 4;
      }
      .deck-section {
        grid-column: 2 / 3;
        grid-row: 2 / 4;
      }
      .test-hand-section {
        grid-column: 1 / -1;
        grid-row: 4 / 5;
        min-height: 550px; /* Increased min-height slightly for zones */
      }

      /* --- Search Styles (Unchanged) --- */
      #searchInput {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
      }
      #searchResults {
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 300px;
        overflow-y: auto;
        border: 1px solid #eee;
        border-top: none;
        border-radius: 0 0 4px 4px;
        background-color: white;
        /* Removed positioning as it was likely for a dropdown */
        /* position: absolute; */
        width: calc(100% - 40px); /* Adjust width based on parent padding */
        /* left: 20px; */
        /* top: 85px; */
        z-index: 10;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }
      #searchResults li {
        padding: 5px 10px;
        cursor: pointer;
        border-bottom: 1px solid #eee;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      #searchResults li:last-child {
        border-bottom: none;
      }
      #searchResults li:hover {
        background-color: #f0f0f0;
      }
      .search-result-image {
        width: 30px;
        height: auto;
        border-radius: 2px;
        flex-shrink: 0;
      }
      .search-result-name {
        font-size: 0.9em;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      #searchResults:empty {
        border: none;
        box-shadow: none;
        max-height: 0;
        /* No need to explicitly hide if empty and position: static */
      }

      /* --- Deck List Styles (Unchanged) --- */
      #deckList {
        list-style: none;
        padding: 0;
        margin-top: 10px;
        max-height: 500px;
        overflow-y: auto;
        flex-grow: 1;
      }
      #deckList li {
        padding: 8px 5px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
      }
      #deckList li:last-child {
        border-bottom: none;
      }
      .card-info {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-grow: 1;
        min-width: 0;
      }
      /* Make card image hoverable */
      .card-image {
        width: 60px;
        height: auto;
        border-radius: 3px;
        vertical-align: middle;
        flex-shrink: 0;
        cursor: help; /* Indicate hover interaction */
      }
      .card-name {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .card-controls {
        display: flex;
        align-items: center;
        gap: 5px;
        flex-shrink: 0;
      }
      .card-quantity input {
        width: 40px;
        text-align: center;
        padding: 4px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }

      /* --- Buttons and Status --- */
      .action-button,
      .delete-card-btn,
      #drawHandButton,
      #drawNextCardButton {
        /* Added new button ID */
        padding: 9px 15px;
        background-color: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        font-size: 0.9em;
        margin-bottom: 10px; /* Consistent margin */
      }

      /* Specific button styles */
      .test-hand-section .action-button {
        /* Style buttons within test section */
        display: inline-block; /* Allow side-by-side */
        width: auto; /* Don't force full width */
        margin-right: 10px; /* Space between buttons */
      }

      .action-button:hover,
      .delete-card-btn:hover,
      #drawHandButton:hover,
      #drawNextCardButton:hover {
        background-color: #0056b3;
      }
      /* Disabled button style */
      .action-button:disabled,
      #drawNextCardButton:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }

      .delete-card-btn {
        background-color: #dc3545;
        padding: 4px 8px;
        font-size: 0.8em;
        line-height: 1;
      }
      .delete-card-btn:hover {
        background-color: #c82333;
      }
      .actions-section .action-button {
        display: block;
        width: 100%;
      } /* Keep actions section buttons full width */

      #status,
      #deckActionStatus,
      #testHandStatus {
        margin-top: 10px;
        font-style: italic;
        color: #555;
        min-height: 1.2em;
        font-size: 0.9em;
      }
      #deckCount {
        text-align: right;
        font-weight: bold;
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #eee;
      }
      .loading::after {
        content: " Loading...";
        display: inline-block;
        margin-left: 5px;
        font-style: italic;
        color: #888;
        font-size: 0.9em;
      }

      /* --- Test Area Enhancements --- */
      .play-area {
        display: flex;
        gap: 15px;
        margin-top: 15px;
        border-top: 1px solid #eee;
        padding-top: 15px;
        flex-grow: 1;
        min-height: 400px; /* Adjusted min-height */
        overflow: hidden;
      }

      .hand-zone {
        flex-basis: 250px;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
      }
      .hand-zone h3 {
        text-align: left;
        margin-bottom: 5px;
        padding-left: 5px;
      }

      /* MODIFIED: Battlefield now contains sub-zones */
      .battlefield-zone {
        flex-grow: 1;
        display: flex; /* Use flex to arrange sub-zones */
        flex-direction: column; /* Stack zones vertically */
        gap: 10px;
        background-color: #e0e0e0; /* Neutral background for container */
        border: 1px solid #ccc; /* Solid border for container */
        border-radius: 5px;
        padding: 10px;
        overflow: hidden; /* Let sub-zones handle internal scroll/overflow if needed */
      }
      /* REMOVED: h3 directly inside .battlefield-zone */

      /* NEW: Sub-zone Styling */
      .bf-subzone {
        flex-grow: 1; /* Share space vertically */
        border-radius: 4px;
        padding: 10px 5px 5px 5px; /* Padding around cards */
        position: relative; /* CRUCIAL for card positioning */
        min-height: 150px; /* Ensure drop target area */
        overflow: hidden; /* Hide card overflow */
        display: flex; /* Use flexbox for cards */
        flex-wrap: wrap; /* Allow cards to wrap */
        align-content: flex-start; /* Align wrapped lines to top */
        gap: 5px; /* Space between cards */
      }
      #generalZone {
        background-color: #e9f5e9; /* Light green */
        border: 1px dashed #9ccc9c;
      }
      #creatureZone {
        background-color: #f5e9e9; /* Light red/pink */
        border: 1px dashed #cc9c9c;
      }
      #landZone {
        background-color: #e9e9f5; /* Light blue/purple */
        border: 1px dashed #9c9ccc;
      }
      /* --- END NEW SUB-ZONE STYLING --- */

      /* Hand card display (Unchanged) */
      #testHandDisplay li {
        padding: 5px;
        border: 1px solid #eee;
        margin-bottom: 4px;
        border-radius: 3px;
        background-color: #fff;
        cursor: pointer;
        transition: background-color 0.2s ease;
        display: flex;
        justify-content: flex-start;
        align-items: center;
        gap: 8px;
      }
      #testHandDisplay li:hover {
        background-color: #f0f8ff;
      }
      #testHandDisplay {
        list-style: none;
        padding: 0 5px 0 0;
        margin: 0;
        max-height: 400px;
        overflow-y: auto;
        flex-grow: 1;
      }

      /* Card on Battlefield */
      .battlefield-card {
        position: absolute; /* Dragging uses absolute positioning */
        width: 65px;
        height: auto;
        border-radius: 4px;
        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        cursor: grab;
        user-select: none;
        transition: box-shadow 0.2s ease;
        background-color: #fff;
        z-index: 1;
      }
      .battlefield-card:active {
        cursor: grabbing;
        box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.5);
        z-index: 1000;
      }
      /* Make battlefield image hoverable */
      .battlefield-card img {
        width: 100%;
        height: auto;
        display: block;
        pointer-events: none; /* Allow drag events on parent */
        cursor: help; /* Suggests hover interaction is available */
      }
      .battlefield-card img.dragging {
        opacity: 0.4;
      }

      /* --- NEW: Image Popup Styles --- */
      #imagePopup {
        position: fixed; /* Position relative to viewport */
        display: none; /* Hidden by default */
        padding: 5px;
        background-color: rgba(0, 0, 0, 0.8);
        border-radius: 6px;
        z-index: 9999; /* High z-index */
        pointer-events: none; /* Prevents popup from blocking mouse events */
        transition: opacity 0.1s ease-in-out; /* Smooth fade (optional) */
        width: 250px; /* Max width to prevent huge images */
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
      }
      #imagePopup img {
        display: block;
        width: 100%; /* Fill the container */
        height: auto;
        border-radius: 4px;
        border: 1px solid #555;
      }
      /* --- END NEW Styles --- */
    </style>
  </head>
  <body>
    <h1>Simple MTG Deck Builder</h1>

    <!-- Grid Item: Search -->
    <div class="search-section">
      <h2>Card Search</h2>
      <input
        type="text"
        id="searchInput"
        placeholder="Start typing card name..."
        autocomplete="off"
      />
      <ul id="searchResults"></ul>
      <div id="status">Type at least 3 characters for suggestions.</div>
    </div>

    <!-- Grid Item: Actions -->
    <div class="actions-section">
      <h2>Deck Actions</h2>
      <button id="saveDeckButton" class="action-button">Save Deck</button>
      <button id="loadDeckButton" class="action-button">Load Deck</button>
      <button id="clearDeckButton" class="action-button">
        Clear Current Deck
      </button>
      <div id="deckActionStatus"></div>
    </div>

    <!-- Grid Item: Deck -->
    <div class="deck-section">
      <h2>Current Deck (<span id="deckTotalCount">0</span> cards)</h2>
      <ul id="deckList"></ul>
      <div id="deckCount">Total: <span id="deckTotalCountBottom">0</span></div>
    </div>

    <!-- Grid Item: Test Area -->
    <div class="test-hand-section">
      <h2>Test Area</h2>
      <button id="drawHandButton" class="action-button">Draw 7 Cards</button>
      <button id="drawNextCardButton" class="action-button" disabled>
        Draw Next Card
      </button>
      <div id="testHandStatus"></div>

      <div class="play-area">
        <div class="hand-zone">
          <h3>Hand (<span id="handCardCount">0</span>)</h3>
          <ul id="testHandDisplay"></ul>
        </div>
        <div class="battlefield-zone" id="battlefieldDisplayContainer">
          <div class="bf-subzone" id="generalZone">
            <h4>General Battlefield</h4>
          </div>
          <div class="bf-subzone" id="creatureZone">
            <h4>Creatures</h4>
          </div>
          <div class="bf-subzone" id="landZone">
            <h4>Lands</h4>
          </div>
        </div>
      </div>
    </div>

    <!-- NEW: Image Popup Element (Placed near end of body) -->
    <div id="imagePopup">
      <img id="popupImage" src="" alt="Card Preview" />
    </div>
    <!-- END NEW Element -->

    <script>
      // --- DOM Element References ---
      const searchInput = document.getElementById("searchInput");
      const searchResults = document.getElementById("searchResults");
      const statusDiv = document.getElementById("status");
      const deckList = document.getElementById("deckList");
      const deckTotalCountSpan = document.getElementById("deckTotalCount");
      const deckTotalCountBottomSpan = document.getElementById(
        "deckTotalCountBottom"
      );
      const saveDeckButton = document.getElementById("saveDeckButton");
      const loadDeckButton = document.getElementById("loadDeckButton");
      const clearDeckButton = document.getElementById("clearDeckButton");
      const deckActionStatus = document.getElementById("deckActionStatus");
      const drawHandButton = document.getElementById("drawHandButton");
      const drawNextCardButton = document.getElementById("drawNextCardButton");
      const testHandDisplay = document.getElementById("testHandDisplay");
      const handCardCountSpan = document.getElementById("handCardCount");
      const testHandStatus = document.getElementById("testHandStatus");
      const battlefieldDisplayContainer = document.getElementById(
        "battlefieldDisplayContainer"
      );
      const generalZone = document.getElementById("generalZone");
      const creatureZone = document.getElementById("creatureZone");
      const landZone = document.getElementById("landZone");
      // NEW: Popup Element References
      const imagePopup = document.getElementById("imagePopup");
      const popupImage = document.getElementById("popupImage");

      const DECK_STORAGE_KEY = "mtgDeckBuilderSimpleDeckV3";

      // --- State Variables ---
      let currentDeck = {}; // { "Card Name": { quantity: number, imageUrl: string, normalImageUrl?: string } } // Added optional normal URL
      let searchAbortController = null;
      let currentHand = []; // Array of { handId: number, name: string, imageUrl: string, normalImageUrl?: string }
      let currentBattlefield = {}; // { "bf-ID": { name: string, imageUrl: string, normalImageUrl?: string, zone: string, x: number, y: number } }
      let currentLibrary = []; // Holds the shuffled deck cards remaining
      let handCardIdCounter = 0;
      let battlefieldCardIdCounter = 0;
      let dragInfo = { cardId: null, offsetX: 0, offsetY: 0 };
      let popupVisible = false; // NEW: Track popup state

      // --- Utility Functions (Mostly Unchanged) ---
      // Debounce implementation
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      // Status update implementation
      function updateStatus(message, isLoading = false) {
        statusDiv.textContent = message;
        if (isLoading) {
          statusDiv.classList.add("loading");
        } else {
          statusDiv.classList.remove("loading");
        }
      }
      function clearStatus() {
        updateStatus("");
      }
      function removeLoadingIndicator() {
        statusDiv.classList.remove("loading");
      }
      // Deck action status implementation
      function updateDeckActionStatus(message) {
        deckActionStatus.textContent = message;
        setTimeout(() => {
          if (deckActionStatus.textContent === message) {
            deckActionStatus.textContent = "";
          }
        }, 4000);
      }
      // HTML escaping implementation
      function escapeHtml(unsafe) {
        if (unsafe === null || unsafe === undefined) return "";
        return unsafe
          .replace(/&/g, "&") // Corrected escaping
          .replace(/</g, "<")
          .replace(/>/g, ">")
          .replace(/"/g, '"')
          .replace(/'/g, "'");
      }

      // --- API Interaction (Modified slightly to potentially grab normal image) ---
      async function performLiveSearch(query) {
        if (searchAbortController) {
          searchAbortController.abort();
        }
        searchAbortController = new AbortController();
        const signal = searchAbortController.signal;

        searchResults.innerHTML = "";
        if (!query || query.length < 3) {
          searchResults.style.display = "none";
          updateStatus("Type at least 3 characters for suggestions.");
          return;
        }

        updateStatus("Searching...", true);
        // Requesting 'normal' size directly in query might not work, we process response
        const apiUrl = `https://api.scryfall.com/cards/search?q=${encodeURIComponent(
          query
        )}&unique=cards&order=name&include_extras=false&include_variations=false`;

        try {
          const response = await fetch(apiUrl, { signal });
          if (!response.ok) {
            if (response.status === 404) {
              updateStatus(`No cards found matching "${escapeHtml(query)}".`);
            } else if (response.status === 400) {
              updateStatus(`Invalid search query. Try different terms.`);
            } else {
              throw new Error(`API Error: ${response.status}`);
            }
            searchResults.style.display = "none";
            return;
          }

          const data = await response.json();
          displaySearchResults(data.data.slice(0, 15)); // Display results uses the raw data
        } catch (error) {
          if (error.name === "AbortError") {
            console.log("Search fetch aborted");
            return;
          }
          console.error("Search Error:", error);
          updateStatus(`Error searching cards: ${escapeHtml(error.message)}`);
          searchResults.style.display = "none";
        } finally {
          removeLoadingIndicator();
          searchAbortController = null;
        }
      }
      const debouncedLiveSearch = debounce(performLiveSearch, 350);

      // --- Display Logic (Modified displaySearchResults, renderDeck, displayHand) ---

      // displaySearchResults - Stores normal URL if available
      function displaySearchResults(cards) {
        searchResults.innerHTML = "";
        if (!cards || cards.length === 0) {
          searchResults.style.display = "none";
          return;
        }
        updateStatus(`${cards.length} result(s) shown. Click to add.`);
        searchResults.style.display = "block";
        cards.forEach((card) => {
          const li = document.createElement("li");
          // Prefer small for list view, store normal for popup/deck
          const smallImageUrl =
            card.image_uris?.small || card.image_uris?.normal || "";
          const normalImageUrl = card.image_uris?.normal || smallImageUrl; // Fallback to small/other if normal missing
          const cardName = card.name || "Unknown Card";

          li.innerHTML = `<img src="${escapeHtml(
            smallImageUrl
          )}" alt="${escapeHtml(
            cardName
          )}" class="search-result-image" loading="lazy"><span class="search-result-name">${escapeHtml(
            cardName
          )}</span>`;
          li.dataset.cardname = cardName;
          // Store both URLs. Keep small as default 'imageurl' for consistency? Let's store normal separately.
          li.dataset.imageurl = smallImageUrl; // Keep this as the primary for adding to deck visually
          li.dataset.normalimageurl = normalImageUrl; // Store the preferred larger URL

          searchResults.appendChild(li);
        });
      }

      // renderDeck - Uses normalImageUrl for potential hover later (though not implemented here yet)
      function renderDeck() {
        deckList.innerHTML = "";
        let totalCards = 0;
        const sortedCardNames = Object.keys(currentDeck).sort();
        sortedCardNames.forEach((cardName) => {
          const cardInfo = currentDeck[cardName];
          if (!cardInfo || cardInfo.quantity <= 0) {
            if (cardInfo) delete currentDeck[cardName];
            return;
          }
          totalCards += cardInfo.quantity;
          const li = document.createElement("li");
          // Use the stored small image URL for the list view image
          const smallImageUrl = cardInfo.imageUrl || "";
          const normalImageUrl = cardInfo.normalImageUrl || smallImageUrl; // Use normal for data/hover

          li.innerHTML = `<div class="card-info"><img src="${escapeHtml(
            smallImageUrl // Display small image in list
          )}" alt="${escapeHtml(
            cardName
          )}" class="card-image" loading="lazy" data-normal-src="${escapeHtml(
            normalImageUrl
          )}"> <!-- Add data-normal-src -->
            <span class="card-name" title="${escapeHtml(
              cardName
            )}">${escapeHtml(cardName)}</span>
          </div>
          <div class="card-controls">
            <span class="card-quantity"><input type="number" min="1" value="${
              cardInfo.quantity
            }" data-cardname="${escapeHtml(
            cardName
          )}" class="quantity-input"></span>
            <button class="delete-card-btn" data-cardname="${escapeHtml(
              cardName
            )}">X</button>
          </div>`;
          deckList.appendChild(li);
        });
        deckTotalCountSpan.textContent = totalCards;
        deckTotalCountBottomSpan.textContent = totalCards;
      }

      // displayHand - Adds normal image URL data attribute
      function displayHand() {
        const handList = document.getElementById("testHandDisplay");
        handList.innerHTML = "";
        currentHand.sort((a, b) => a.name.localeCompare(b.name));
        currentHand.forEach((card) => {
          const li = document.createElement("li");
          li.dataset.handId = card.handId;
          const smallImageUrl = card.imageUrl || ""; // The primary URL stored
          const normalImageUrl = card.normalImageUrl || smallImageUrl; // The larger version
          const safeCardName = card.name || "Unknown Card";

          li.innerHTML = `<div class="card-info">
            <img src="${escapeHtml(smallImageUrl)}" alt="${escapeHtml(
            safeCardName
          )}" class="card-image" loading="lazy" data-normal-src="${escapeHtml(
            normalImageUrl
          )}"> <!-- Add data-normal-src -->
            <span class="card-name" title="${escapeHtml(
              safeCardName
            )}">${escapeHtml(safeCardName)}</span>
          </div>`;
          li.addEventListener("click", handlePlayCardFromHand);
          handList.appendChild(li);
        });
        handCardCountSpan.textContent = currentHand.length;
      }

      // displayBattlefield - Adds normal image URL data attribute to inner image
      function displayBattlefield() {
        generalZone.innerHTML = "<h4>General Battlefield</h4>";
        creatureZone.innerHTML = "<h4>Creatures</h4>";
        landZone.innerHTML = "<h4>Lands</h4>";

        Object.entries(currentBattlefield).forEach(([id, card]) => {
          const cardDiv = document.createElement("div");
          cardDiv.classList.add("battlefield-card");
          cardDiv.dataset.battlefieldId = id;
          cardDiv.draggable = true;

          const posX = typeof card.x === "number" ? card.x : 10;
          const posY = typeof card.y === "number" ? card.y : 10;
          cardDiv.style.left = `${posX}px`;
          cardDiv.style.top = `${posY}px`;

          const smallImageUrl = card.imageUrl || "";
          const normalImageUrl = card.normalImageUrl || smallImageUrl;
          const safeCardName = card.name || "Unknown Card";

          // Put the data-normal-src on the IMG tag itself
          cardDiv.innerHTML = `<img src="${escapeHtml(
            smallImageUrl
          )}" alt="${escapeHtml(safeCardName)}" title="${escapeHtml(
            safeCardName
          )}" data-normal-src="${escapeHtml(normalImageUrl)}">`;

          cardDiv.addEventListener("dragstart", handleDragStart);
          cardDiv.addEventListener("dragend", handleDragEnd);

          switch (card.zone) {
            case "land":
              landZone.appendChild(cardDiv);
              break;
            case "creature":
              creatureZone.appendChild(cardDiv);
              break;
            case "general":
            default:
              generalZone.appendChild(cardDiv);
              break;
          }
        });
      }

      // --- Deck Management Logic (Modified addCardToDeck) ---

      // addCardToDeck - Stores both image URLs
      function addCardToDeck(cardName, smallImageUrl, normalImageUrl) {
        if (!cardName) {
          console.error("Attempted to add card with no name.");
          updateDeckActionStatus("Error: Cannot add card without a name.");
          return;
        }
        const existingCard = currentDeck[cardName];
        const safeCardName = escapeHtml(cardName);
        if (existingCard) {
          existingCard.quantity++;
          updateDeckActionStatus(
            `Incremented "${safeCardName}" to ${existingCard.quantity}.`
          );
        } else {
          const safeSmallUrl =
            typeof smallImageUrl === "string" ? smallImageUrl : "";
          const safeNormalUrl =
            typeof normalImageUrl === "string" ? normalImageUrl : safeSmallUrl; // Fallback
          if (!safeSmallUrl) {
            console.warn(`Missing image URL for card: ${safeCardName}.`);
          }
          currentDeck[cardName] = {
            quantity: 1,
            imageUrl: safeSmallUrl, // Primary visual URL (small)
            normalImageUrl: safeNormalUrl, // Larger URL for popups etc.
          };
          updateDeckActionStatus(`Added "${safeCardName}" to deck.`);
        }
        renderDeck();
        searchInput.value = "";
        searchResults.innerHTML = "";
        searchResults.style.display = "none";
        clearStatus();
      }

      function updateCardQuantity(cardName, newQuantity) {
        const quantity = parseInt(newQuantity, 10);
        const cardInfo = currentDeck[cardName];
        if (!cardInfo) return;
        const safeCardName = escapeHtml(cardName);
        if (isNaN(quantity) || quantity <= 0) {
          deleteCardFromDeck(cardName);
          updateDeckActionStatus(
            `Removed "${safeCardName}" (quantity set to 0 or less).`
          );
        } else {
          cardInfo.quantity = quantity;
          updateDeckActionStatus(
            `Updated "${safeCardName}" quantity to ${quantity}.`
          );
          renderDeck(); // Re-render to reflect potential changes if needed (though input updates visually)
        }
      }
      function deleteCardFromDeck(cardName) {
        if (currentDeck[cardName]) {
          const safeCardName = escapeHtml(cardName);
          delete currentDeck[cardName];
          updateDeckActionStatus(`Removed "${safeCardName}" from deck.`);
          renderDeck();
        }
      }
      function clearDeck() {
        if (
          confirm(
            "Are you sure you want to clear the current deck? This also clears the test area. This cannot be undone unless saved."
          )
        ) {
          currentDeck = {};
          updateDeckActionStatus("Deck cleared.");
          renderDeck();
          clearTestArea(); // Now correctly named
        }
      }

      // --- Local Storage (Slight modification for new data structure) ---
      function saveDeck() {
        try {
          // No change needed here, JSON.stringify handles the structure
          localStorage.setItem(DECK_STORAGE_KEY, JSON.stringify(currentDeck));
          updateDeckActionStatus("Deck saved successfully!");
        } catch (error) {
          console.error("Error saving deck:", error);
          updateDeckActionStatus(
            "Error saving deck. LocalStorage might be full or disabled."
          );
        }
      }
      function loadDeck() {
        const savedDeck = localStorage.getItem(DECK_STORAGE_KEY);
        let deckLoaded = false;
        let loadedData = {}; // Use temporary object for loading

        if (savedDeck) {
          try {
            const parsedDeck = JSON.parse(savedDeck);
            if (
              typeof parsedDeck === "object" &&
              parsedDeck !== null &&
              !Array.isArray(parsedDeck)
            ) {
              let isValid = true;
              const validatedDeck = {};
              for (const key in parsedDeck) {
                if (typeof key !== "string" || key.trim() === "") {
                  isValid = false;
                  break;
                }
                const entry = parsedDeck[key];
                // Validate basic structure + new optional field
                if (
                  typeof entry !== "object" ||
                  entry === null ||
                  typeof entry.quantity !== "number" ||
                  !Number.isInteger(entry.quantity) ||
                  entry.quantity <= 0 ||
                  typeof entry.imageUrl !== "string" || // Must have small/primary URL
                  (entry.hasOwnProperty("normalImageUrl") &&
                    typeof entry.normalImageUrl !== "string") // normalImageUrl must be string if present
                ) {
                  isValid = false;
                  break;
                }
                validatedDeck[key] = {
                  quantity: entry.quantity,
                  imageUrl: entry.imageUrl,
                  // Ensure normalImageUrl exists, defaulting to imageUrl if missing in old saves
                  normalImageUrl: entry.normalImageUrl || entry.imageUrl,
                };
              }
              if (isValid) {
                loadedData = validatedDeck; // Load into temp object first
                updateDeckActionStatus("Deck loaded successfully!");
                deckLoaded = true;
              } else {
                updateDeckActionStatus(
                  "Failed to load deck: Invalid data format found. Deck cleared."
                );
                console.warn(
                  "Invalid deck structure found in localStorage, deck reset.",
                  parsedDeck
                );
                loadedData = {};
              }
            } else {
              updateDeckActionStatus(
                "Failed to load deck: Invalid data type in storage. Deck cleared."
              );
              console.warn(
                "Invalid data type found in localStorage:",
                parsedDeck
              );
              loadedData = {};
            }
          } catch (error) {
            console.error("Error parsing saved deck:", error);
            updateDeckActionStatus(
              "Error loading deck: Could not parse saved data. Deck cleared."
            );
            loadedData = {};
          }
        } else {
          loadedData = {}; // Ensure it's empty if nothing found
        }

        currentDeck = loadedData; // Assign the loaded or cleared data to the main state
        clearTestArea();
        renderDeck();

        if (!deckLoaded && Object.keys(currentDeck).length === 0) {
          setTimeout(() => {
            if (
              deckActionStatus.textContent === "" ||
              deckActionStatus.textContent === "No saved deck found."
            ) {
              updateDeckActionStatus("Create a new deck or load a saved one.");
            }
          }, 100);
        } else if (!deckLoaded && Object.keys(currentDeck).length > 0) {
          updateDeckActionStatus("No saved deck found. Using current deck.");
        }
      }

      // --- Test Hand / Play Area Logic (Modified drawTestHand, handlePlayCardFromHand) ---

      // drawTestHand - Passes normalImageUrl
      function drawTestHand() {
        clearTestArea();
        const deckArray = [];
        for (const cardName in currentDeck) {
          const cardInfo = currentDeck[cardName];
          if (cardInfo && cardInfo.quantity > 0) {
            for (let i = 0; i < cardInfo.quantity; i++) {
              deckArray.push({
                name: cardName,
                imageUrl: cardInfo.imageUrl,
                normalImageUrl: cardInfo.normalImageUrl, // Pass along normal URL
              });
            }
          }
        }

        const deckSize = deckArray.length;
        if (deckSize < 7) {
          testHandStatus.textContent = `Cannot draw hand: Deck only has ${deckSize} cards (needs at least 7).`;
          disableDrawNextButton();
          return;
        }

        for (let i = deckArray.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deckArray[i], deckArray[j]] = [deckArray[j], deckArray[i]];
        }

        const hand = deckArray.slice(0, 7);
        currentHand = hand.map((card) => ({
          handId: handCardIdCounter++,
          name: card.name,
          imageUrl: card.imageUrl,
          normalImageUrl: card.normalImageUrl, // Store in hand state
        }));

        currentLibrary = deckArray.slice(7); // Library contains objects with both URLs too

        testHandStatus.textContent = `Drew 7 cards. ${currentLibrary.length} cards left in library.`;
        displayHand();
        displayBattlefield();
        enableDrawNextButton();
      }

      // drawNextCard - Passes normalImageUrl
      function drawNextCard() {
        if (currentLibrary.length === 0) {
          testHandStatus.textContent = "Cannot draw: Library is empty.";
          disableDrawNextButton();
          return;
        }
        const nextCard = currentLibrary.shift();
        currentHand.push({
          handId: handCardIdCounter++,
          name: nextCard.name,
          imageUrl: nextCard.imageUrl,
          normalImageUrl: nextCard.normalImageUrl, // Add to hand state
        });
        displayHand();
        testHandStatus.textContent = `Drew ${escapeHtml(nextCard.name)}. ${
          currentLibrary.length
        } cards left in library.`;
        if (currentLibrary.length === 0) {
          disableDrawNextButton();
          testHandStatus.textContent += " Library is now empty.";
        }
      }

      function enableDrawNextButton() {
        drawNextCardButton.disabled = false;
      }
      function disableDrawNextButton() {
        drawNextCardButton.disabled = true;
      }
      function clearTestArea() {
        currentHand = [];
        currentBattlefield = {};
        currentLibrary = [];
        handCardIdCounter = 0;
        battlefieldCardIdCounter = 0;
        dragInfo = { cardId: null, offsetX: 0, offsetY: 0 };
        if (testHandDisplay) testHandDisplay.innerHTML = "";
        if (generalZone) generalZone.innerHTML = "<h4>General Battlefield</h4>";
        if (creatureZone) creatureZone.innerHTML = "<h4>Creatures</h4>";
        if (landZone) landZone.innerHTML = "<h4>Lands</h4>";
        if (handCardCountSpan) handCardCountSpan.textContent = "0";
        if (testHandStatus) testHandStatus.textContent = "";
        disableDrawNextButton();
        hideImagePopup(); // Hide popup if area is cleared
      }

      // handlePlayCardFromHand - Passes normalImageUrl to battlefield state
      function handlePlayCardFromHand(event) {
        const listItem = event.currentTarget;
        const handId = parseInt(listItem.dataset.handId, 10);
        const cardIndex = currentHand.findIndex(
          (card) => card.handId === handId
        );
        if (cardIndex > -1) {
          const [cardToPlay] = currentHand.splice(cardIndex, 1);
          const battlefieldId = `bf-${battlefieldCardIdCounter++}`;
          const initialX = 10 + Math.floor(Math.random() * 10);
          const initialY = 10 + Math.floor(Math.random() * 10);
          currentBattlefield[battlefieldId] = {
            name: cardToPlay.name,
            imageUrl: cardToPlay.imageUrl, // Small URL
            normalImageUrl: cardToPlay.normalImageUrl, // Normal URL
            zone: "general",
            x: initialX,
            y: initialY,
          };
          displayHand();
          displayBattlefield();
        }
      }

      // --- Drag and Drop Handlers (Unchanged) ---
      function handleDragStart(event) {
        const cardElement = event.target.closest(".battlefield-card");
        if (!cardElement || !cardElement.dataset.battlefieldId) return;
        const cardId = cardElement.dataset.battlefieldId;
        if (!currentBattlefield[cardId]) {
          console.warn("DragStart failed: Card ID not found in state:", cardId);
          event.preventDefault();
          return;
        }
        dragInfo.cardId = cardId;
        const rect = cardElement.getBoundingClientRect();
        dragInfo.offsetX = event.clientX - rect.left;
        dragInfo.offsetY = event.clientY - rect.top;
        event.dataTransfer.setData("text/plain", cardId);
        event.dataTransfer.effectAllowed = "move";
        setTimeout(() => {
          // Apply class to the inner image
          const img = cardElement.querySelector("img");
          if (img) img.classList.add("dragging");
        }, 0);
        event.stopPropagation();
        hideImagePopup(); // Hide popup during drag
      }
      function handleDragEnd(event) {
        const cardId = dragInfo.cardId;
        if (cardId) {
          // Find the potentially moved element's image to remove styling
          const cardElement = battlefieldDisplayContainer.querySelector(
            `[data-battlefield-id="${cardId}"]`
          );
          const img = cardElement?.querySelector("img");
          if (img) img.classList.remove("dragging");
        }
        dragInfo.cardId = null;
        dragInfo.offsetX = 0;
        dragInfo.offsetY = 0;
      }
      function handleDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = "move";
      }
      function handleDrop(event) {
        event.preventDefault();
        event.stopPropagation();
        const targetZoneElement = event.currentTarget;
        const draggedCardId = dragInfo.cardId;
        if (!draggedCardId || !currentBattlefield[draggedCardId]) {
          console.warn(
            "Drop failed: Invalid dragged card ID or card not in state."
          );
          return;
        }
        let targetZoneId = "general";
        if (targetZoneElement.id === "landZone") targetZoneId = "land";
        else if (targetZoneElement.id === "creatureZone")
          targetZoneId = "creature";

        const zoneRect = targetZoneElement.getBoundingClientRect();
        let newX = event.clientX - zoneRect.left - dragInfo.offsetX;
        let newY = event.clientY - zoneRect.top - dragInfo.offsetY;

        // Use querySelector on the *entire* container to find the element, regardless of old zone
        const cardElement = battlefieldDisplayContainer.querySelector(
          `[data-battlefield-id="${draggedCardId}"]`
        );
        if (!cardElement) {
          console.warn(
            "Drop failed: Could not find card element for boundary check."
          );
          return;
        }
        const cardWidth = cardElement.offsetWidth;
        const cardHeight = cardElement.offsetHeight;
        const containerWidth = targetZoneElement.clientWidth;
        const containerHeight = targetZoneElement.clientHeight;
        newX = Math.max(0, Math.min(newX, containerWidth - cardWidth));
        newY = Math.max(0, Math.min(newY, containerHeight - cardHeight));
        newX = Math.max(0, newX);
        newY = Math.max(0, newY);

        currentBattlefield[draggedCardId].zone = targetZoneId;
        currentBattlefield[draggedCardId].x = newX;
        currentBattlefield[draggedCardId].y = newY;
        displayBattlefield(); // Re-render places it in the new zone's DOM
      }

      // --- NEW: Image Popup Logic ---
      function showImagePopup(event, targetImage) {
        // Determine the correct larger image URL
        let largeImageUrl =
          targetImage.dataset.normalSrc || targetImage.getAttribute("src"); // Use data-normal-src first

        // If the URL still looks like a 'small' version, try replacing it just in case
        if (largeImageUrl && largeImageUrl.includes("/small.")) {
          largeImageUrl = largeImageUrl.replace("/small.", "/normal.");
        } else if (largeImageUrl && largeImageUrl.includes("size=small")) {
          largeImageUrl = largeImageUrl.replace("size=small", "size=normal");
        }

        if (!largeImageUrl) return; // Don't show if no URL

        popupImage.src = largeImageUrl; // Set the source
        // Error handler to fallback if 'normal' fails (e.g., 404)
        popupImage.onerror = () => {
          console.warn(
            `Failed to load large image: ${largeImageUrl}, falling back.`
          );
          popupImage.src = targetImage.getAttribute("src"); // Fallback to original src
          popupImage.onerror = null; // Prevent infinite loop if small also fails
        };

        imagePopup.style.display = "block";
        popupVisible = true;
        moveImagePopup(event); // Position immediately
      }

      function hideImagePopup() {
        imagePopup.style.display = "none";
        popupImage.src = ""; // Clear src to prevent loading old image briefly
        popupImage.onerror = null; // Clear error handler
        popupVisible = false;
      }

      function moveImagePopup(event) {
        if (!popupVisible) return;

        const offset = 15; // Pixels away from cursor
        const popupWidth = imagePopup.offsetWidth;
        const popupHeight = imagePopup.offsetHeight;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let top = event.clientY + offset;
        let left = event.clientX + offset;

        // Boundary checks
        if (left + popupWidth > viewportWidth) {
          left = event.clientX - popupWidth - offset; // Move to left of cursor
        }
        if (top + popupHeight > viewportHeight) {
          top = event.clientY - popupHeight - offset; // Move above cursor
        }

        // Ensure it doesn't go off the top/left either
        if (top < 0) top = offset;
        if (left < 0) left = offset;

        imagePopup.style.top = `${top}px`;
        imagePopup.style.left = `${left}px`;
      }

      // --- Event Listeners ---

      // Search (Modified results click to pass normal URL)
      searchInput.addEventListener("input", (event) => {
        debouncedLiveSearch(event.target.value.trim());
      });
      searchResults.addEventListener("click", (event) => {
        const listItem = event.target.closest("li");
        if (listItem && listItem.dataset.cardname) {
          // Pass both URLs
          addCardToDeck(
            listItem.dataset.cardname,
            listItem.dataset.imageurl,
            listItem.dataset.normalimageurl // Pass the normal URL
          );
        }
      });
      document.addEventListener("click", (event) => {
        const searchSection = event.target.closest(".search-section");
        const resultsList = event.target.closest("#searchResults");
        if (!searchSection && !resultsList) {
          searchResults.innerHTML = "";
          searchResults.style.display = "none";
        }
      });
      searchInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          const firstResult = searchResults.querySelector("li");
          if (firstResult && firstResult.dataset.cardname) {
            addCardToDeck(
              firstResult.dataset.cardname,
              firstResult.dataset.imageurl,
              firstResult.dataset.normalimageurl // Pass normal URL on enter too
            );
          } else {
            // Maybe trigger search again? Or do nothing if no results shown.
            // performLiveSearch(searchInput.value.trim());
          }
        }
      });

      // Deck List (Unchanged behavior, hover handled by delegated listeners below)
      deckList.addEventListener("click", (event) => {
        if (event.target.classList.contains("delete-card-btn")) {
          const cardName = event.target.getAttribute("data-cardname");
          if (cardName) deleteCardFromDeck(cardName);
        }
      });
      deckList.addEventListener("change", (event) => {
        if (event.target.classList.contains("quantity-input")) {
          const cardName = event.target.getAttribute("data-cardname");
          if (cardName) updateCardQuantity(cardName, event.target.value);
        }
      });

      // Action Buttons
      saveDeckButton.addEventListener("click", saveDeck);
      loadDeckButton.addEventListener("click", loadDeck);
      clearDeckButton.addEventListener("click", clearDeck);
      drawHandButton.addEventListener("click", drawTestHand);
      drawNextCardButton.addEventListener("click", drawNextCard);

      // Drag Listeners for Battlefield Zones
      [generalZone, creatureZone, landZone].forEach((zone) => {
        zone.addEventListener("dragover", handleDragOver);
        zone.addEventListener("drop", handleDrop);
      });

      // --- NEW: Delegated Event Listeners for Image Popup ---
      function setupPopupListeners() {
        const containers = [
          searchResults,
          deckList,
          testHandDisplay,
          battlefieldDisplayContainer,
        ];

        containers.forEach((container) => {
          if (!container) return; // Skip if a container doesn't exist

          // Mouse Over/Enter
          container.addEventListener("mouseover", (event) => {
            let targetImg = null;
            // Check if target is one of our images
            if (event.target.matches(".search-result-image, .card-image")) {
              targetImg = event.target;
            } else if (event.target.matches(".battlefield-card")) {
              // For battlefield, the target might be the div, get the img inside
              targetImg = event.target.querySelector("img");
            } else if (
              event.target.parentElement?.matches(".battlefield-card")
            ) {
              // Or if target is the image itself inside battlefield card
              targetImg = event.target;
            }

            if (targetImg) {
              showImagePopup(event, targetImg);
            }
          });

          // Mouse Move
          container.addEventListener("mousemove", (event) => {
            // Only move if the popup is visible (performance)
            // We don't need to check the target again, just the visibility state
            if (popupVisible) {
              moveImagePopup(event);
            }
          });

          // Mouse Out/Leave
          container.addEventListener("mouseout", (event) => {
            let relatedTargetIsPopup = imagePopup.contains(event.relatedTarget);
            let targetIsImageOrParent =
              event.target.matches(
                ".search-result-image, .card-image, .battlefield-card"
              ) || event.target.parentElement?.matches(".battlefield-card");

            // Hide if moving out of a relevant image *and* not moving into the popup itself
            if (targetIsImageOrParent && !relatedTargetIsPopup) {
              hideImagePopup();
            }
          });
        });

        // Add a listener to the popup itself in case the mouse moves onto it briefly
        imagePopup.addEventListener("mouseout", (event) => {
          // Check if the mouse is moving to something *outside* the popup and its trigger elements
          const isMovingToTrigger = event.relatedTarget?.matches(
            ".search-result-image, .card-image, .battlefield-card img, .battlefield-card"
          );
          if (!imagePopup.contains(event.relatedTarget) && !isMovingToTrigger) {
            hideImagePopup();
          }
        });
      }

      // --- Initial Load ---
      document.addEventListener("DOMContentLoaded", () => {
        loadDeck(); // Handles initial state, rendering, messages, and test area clearing
        disableDrawNextButton(); // Ensure draw next is disabled initially
        setupPopupListeners(); // NEW: Set up the delegated listeners for the popup
      });
    </script>
  </body>
</html>
