<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple MTG Deck Builder (w/ Play Area)</title>
    <style>
      /* --- Base Styles (mostly unchanged) --- */
      body {
        font-family: sans-serif;
        display: grid;
        grid-template-columns: 1fr 2fr; /* Search/Actions on left, Deck on right */
        gap: 20px;
        max-width: 1300px; /* Increased width slightly */
        margin: 20px auto;
        padding: 15px;
        background-color: #f0f2f5; /* Slightly different background */
      }

      h1,
      h2 {
        text-align: center;
        color: #333;
        grid-column: 1 / -1; /* Span across both columns */
        margin-bottom: 15px;
      }
      h3 {
        /* Basic h3 style */
        margin-top: 0;
        margin-bottom: 10px;
        color: #444;
      }

      .search-section,
      .deck-section,
      .actions-section,
      .test-hand-section {
        background-color: #fff;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        display: flex; /* Use flexbox for internal layout */
        flex-direction: column;
      }

      .search-section {
        grid-column: 1 / 2;
        grid-row: 2 / 3;
        position: relative; /* For positioning results */
      }
      .deck-section {
        grid-column: 2 / 3;
        grid-row: 2 / 5; /* Span more rows */
      }
      .actions-section {
        grid-column: 1 / 2;
        grid-row: 3 / 4;
      }
      .test-hand-section {
        grid-column: 1 / 2;
        grid-row: 4 / 5;
        min-height: 450px; /* Ensure enough space for play area */
      }

      #searchInput {
        width: 100%; /* Take full width */
        padding: 10px;
        margin-bottom: 10px; /* Space below input */
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box; /* Include padding in width */
      }

      /* --- Search Results Styling (MODIFIED) --- */
      #searchResults {
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 300px; /* Increased height slightly */
        overflow-y: auto;
        border: 1px solid #eee;
        border-top: none; /* Attach visually to input */
        border-radius: 0 0 4px 4px;
        background-color: white;
        position: absolute; /* Position below input */
        width: calc(100% - 40px); /* Match parent padding */
        left: 20px; /* Match parent padding */
        top: 95px; /* Adjust based on input height + margin + heading */
        z-index: 10; /* Ensure it's above other elements if needed */
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      #searchResults li {
        padding: 5px 10px; /* Adjusted padding */
        cursor: pointer;
        border-bottom: 1px solid #eee;
        display: flex; /* Use flexbox for layout */
        align-items: center; /* Vertically align items */
        gap: 8px; /* Space between image and text */
      }

      #searchResults li:last-child {
        border-bottom: none;
      }

      #searchResults li:hover {
        background-color: #f0f0f0;
      }

      .search-result-image {
        width: 30px; /* Smaller image for search results */
        height: auto;
        border-radius: 2px;
        flex-shrink: 0; /* Don't shrink image */
      }

      .search-result-name {
        font-size: 0.9em;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      /* Hide search results when empty */
      #searchResults:empty {
        border: none;
        box-shadow: none;
        max-height: 0; /* Collapse when empty */
      }

      /* --- Deck List Styling (mostly unchanged) --- */
      #deckList {
        list-style: none;
        padding: 0;
        margin-top: 10px;
        max-height: 500px; /* Allow more vertical space */
        overflow-y: auto;
        flex-grow: 1; /* Allow list to take available space */
      }

      #deckList li {
        padding: 8px 5px;
        border-bottom: 1px solid #eee;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px; /* Space between elements */
      }

      #deckList li:last-child {
        border-bottom: none;
      }

      .card-info {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-grow: 1; /* Take available space */
        min-width: 0; /* Prevent flex item from overflowing */
      }

      .card-image {
        width: 40px; /* Small thumbnail */
        height: auto;
        border-radius: 3px;
        vertical-align: middle;
        flex-shrink: 0; /* Prevent image shrinking */
      }

      .card-name {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .card-controls {
        display: flex;
        align-items: center;
        gap: 5px;
        flex-shrink: 0; /* Prevent controls shrinking */
      }

      .card-quantity input {
        width: 40px;
        text-align: center;
        padding: 4px;
        border: 1px solid #ccc;
        border-radius: 3px;
      }

      /* --- Buttons and Status (unchanged) --- */
      .action-button,
      .delete-card-btn,
      #drawHandButton {
        padding: 9px 15px;
        background-color: #007bff; /* Updated button color */
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        font-size: 0.9em;
      }

      .action-button:hover,
      .delete-card-btn:hover,
      #drawHandButton:hover {
        background-color: #0056b3;
      }

      .delete-card-btn {
        background-color: #dc3545;
        padding: 4px 8px; /* Make delete smaller */
        font-size: 0.8em;
        line-height: 1; /* Adjust line height for small button */
      }
      .delete-card-btn:hover {
        background-color: #c82333;
      }

      .action-button {
        display: block;
        width: 100%;
        margin-bottom: 10px;
      }

      #status,
      #deckActionStatus,
      #testHandStatus {
        margin-top: 10px;
        font-style: italic;
        color: #555;
        min-height: 1.2em;
        font-size: 0.9em;
      }

      #deckCount {
        text-align: right;
        font-weight: bold;
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid #eee;
      }

      /* Simple loading indicator */
      .loading::after {
        content: " Loading...";
        display: inline-block; /* Ensure it flows correctly */
        margin-left: 5px;
        font-style: italic;
        color: #888;
        font-size: 0.9em;
      }

      /* --- Test Area Enhancements --- */
      .play-area {
        display: flex;
        gap: 15px;
        margin-top: 15px;
        border-top: 1px solid #eee;
        padding-top: 15px;
        /* Allow flex items to grow/shrink */
        flex-grow: 1;
        min-height: 300px; /* Ensure space */
        overflow: hidden; /* Prevent content spilling out */
      }

      .hand-zone {
        flex-basis: 250px; /* Fixed width for hand */
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
      }
      .hand-zone h3 {
        text-align: left;
        font-size: 1em;
        margin-bottom: 5px;
        padding-left: 5px;
      }

      .battlefield-zone {
        flex-grow: 1; /* Takes remaining space */
        background-color: #e9f5e9; /* Light green background */
        border: 1px dashed #9ccc9c;
        border-radius: 5px;
        position: relative; /* Crucial for absolute positioning of cards */
        min-height: 300px; /* Ensure drop target area */
        padding: 5px; /* Small padding */
        overflow: hidden; /* Hide potential overflow during drag */
      }
      .battlefield-zone h3 {
        text-align: center;
        font-size: 1em;
        margin-bottom: 5px;
        color: #3a5a3a;
      }

      /* Hand card display */
      #testHandDisplay li {
        /* Styles for individual hand items */
        padding: 5px;
        border: 1px solid #eee;
        margin-bottom: 4px;
        border-radius: 3px;
        background-color: #fff;
        cursor: pointer; /* Indicate it can be clicked */
        transition: background-color 0.2s ease;
        display: flex; /* Override deck list styles if needed */
        justify-content: flex-start; /* Align content to start */
        align-items: center;
        gap: 8px;
      }
      #testHandDisplay li:hover {
        background-color: #f0f8ff; /* Light blue hover */
      }

      /* Make hand list scrollable if needed */
      #testHandDisplay {
        /* Styles for the hand list container */
        list-style: none;
        padding: 0 5px 0 0; /* Add padding for scrollbar */
        margin: 0;
        max-height: 400px; /* Adjust as needed */
        overflow-y: auto;
        flex-grow: 1; /* Take available space in hand-zone */
      }

      /* Card on Battlefield */
      .battlefield-card {
        position: absolute; /* Allows dragging */
        width: 65px; /* Slightly larger image */
        height: auto;
        border-radius: 4px;
        box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        cursor: grab; /* Indicate draggable */
        user-select: none; /* Prevent text selection during drag */
        transition: box-shadow 0.2s ease; /* Feedback on hover/drag */
        background-color: #fff; /* Ensure it has a background */
        z-index: 1; /* Base stacking context */
      }
      .battlefield-card:active {
        cursor: grabbing;
        box-shadow: 2px 2px 6px rgba(0, 0, 0, 0.5);
        z-index: 1000; /* Bring to front while dragging */
      }
      .battlefield-card img {
        /* Style image inside the battlefield card div */
        width: 100%;
        height: auto;
        display: block; /* Remove extra space below image */
        pointer-events: none; /* Prevent image from interfering with drag events on parent */
      }

      /* Style the ghost image */
      .battlefield-card img.dragging {
        opacity: 0.4;
      }
    </style>
  </head>
  <body>
    <h1>Simple MTG Deck Builder</h1>

    <div class="search-section">
      <h2>Card Search</h2>
      <input
        type="text"
        id="searchInput"
        placeholder="Start typing card name..."
        autocomplete="off"
      />
      <ul id="searchResults"></ul>
      <div id="status">Type at least 3 characters for suggestions.</div>
    </div>

    <div class="actions-section">
      <h2>Deck Actions</h2>
      <button id="saveDeckButton" class="action-button">Save Deck</button>
      <button id="loadDeckButton" class="action-button">Load Deck</button>
      <button id="clearDeckButton" class="action-button">
        Clear Current Deck
      </button>
      <div id="deckActionStatus"></div>
    </div>

    <!-- MODIFIED Test Hand Section -->
    <div class="test-hand-section">
      <h2>Test Area</h2>
      <button id="drawHandButton" class="action-button">Draw 7 Cards</button>
      <div id="testHandStatus"></div>

      <div class="play-area">
        <div class="hand-zone">
          <h3>Hand (<span id="handCardCount">0</span>)</h3>
          <ul id="testHandDisplay">
            <!-- Hand cards will be populated here -->
          </ul>
        </div>
        <div class="battlefield-zone">
          <h3>Battlefield</h3>
          <div id="battlefieldDisplay">
            <!-- Cards moved here will be draggable -->
          </div>
        </div>
      </div>
    </div>
    <!-- END MODIFIED Test Hand Section -->

    <div class="deck-section">
      <h2>Current Deck (<span id="deckTotalCount">0</span> cards)</h2>
      <ul id="deckList">
        <!-- Deck items will be populated here -->
      </ul>
      <div id="deckCount">Total: <span id="deckTotalCountBottom">0</span></div>
    </div>

    <script>
      const searchInput = document.getElementById("searchInput");
      const searchResults = document.getElementById("searchResults");
      const statusDiv = document.getElementById("status");

      const deckList = document.getElementById("deckList");
      const deckTotalCountSpan = document.getElementById("deckTotalCount");
      const deckTotalCountBottomSpan = document.getElementById(
        "deckTotalCountBottom"
      );

      const saveDeckButton = document.getElementById("saveDeckButton");
      const loadDeckButton = document.getElementById("loadDeckButton");
      const clearDeckButton = document.getElementById("clearDeckButton");
      const deckActionStatus = document.getElementById("deckActionStatus");

      const drawHandButton = document.getElementById("drawHandButton");
      const testHandDisplay = document.getElementById("testHandDisplay"); // Hand list UL
      const battlefieldDisplay = document.getElementById("battlefieldDisplay"); // Battlefield div
      const handCardCountSpan = document.getElementById("handCardCount");
      const testHandStatus = document.getElementById("testHandStatus");

      const DECK_STORAGE_KEY = "mtgDeckBuilderSimpleDeckV3";

      // --- State Variables ---
      let currentDeck = {}; // { "Card Name": { quantity: number, imageUrl: string } }
      let searchAbortController = null;
      let currentHand = []; // Array of { handId: number, name: string, imageUrl: string }
      let currentBattlefield = {}; // { "bf-ID": { name: string, imageUrl: string, x: number, y: number } }
      let handCardIdCounter = 0;
      let battlefieldCardIdCounter = 0;
      let dragInfo = { cardId: null, offsetX: 0, offsetY: 0 }; // Store drag start info

      // --- Utility Functions ---
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      function updateStatus(message, isLoading = false) {
        statusDiv.textContent = message;
        if (isLoading) {
          statusDiv.classList.add("loading");
        } else {
          statusDiv.classList.remove("loading");
        }
      }
      function clearStatus() {
        updateStatus("");
      }
      function removeLoadingIndicator() {
        statusDiv.classList.remove("loading");
      }
      function updateDeckActionStatus(message) {
        deckActionStatus.textContent = message;
        setTimeout(() => {
          if (deckActionStatus.textContent === message) {
            deckActionStatus.textContent = "";
          }
        }, 4000);
      }
      function escapeHtml(unsafe) {
        if (unsafe === null || unsafe === undefined) return "";
        return unsafe
          .replace(/&/g, "&") // Must be first
          .replace(/</g, "<")
          .replace(/>/g, ">")
          .replace(/"/g, '"')
          .replace(/'/g, "'"); // Use HTML entity for single quote
      }

      // --- API Interaction ---
      async function performLiveSearch(query) {
        if (searchAbortController) {
          searchAbortController.abort();
        }
        searchAbortController = new AbortController();
        const signal = searchAbortController.signal;

        searchResults.innerHTML = "";
        if (!query || query.length < 3) {
          searchResults.style.display = "none"; // Hide empty results
          updateStatus("Type at least 3 characters for suggestions.");
          return;
        }

        updateStatus("Searching...", true);
        const apiUrl = `https://api.scryfall.com/cards/search?q=${encodeURIComponent(
          query
        )}&unique=cards&order=name&include_extras=false&include_variations=false`;

        try {
          const response = await fetch(apiUrl, { signal });
          if (!response.ok) {
            if (response.status === 404) {
              updateStatus(`No cards found matching "${query}".`);
            } else if (response.status === 400) {
              updateStatus(`Invalid search query. Try different terms.`);
            } else {
              throw new Error(`API Error: ${response.status}`);
            }
            searchResults.style.display = "none"; // Hide if error/not found
            return;
          }

          const data = await response.json();
          displaySearchResults(data.data.slice(0, 15));
        } catch (error) {
          if (error.name === "AbortError") {
            console.log("Search fetch aborted");
            return;
          }
          console.error("Search Error:", error);
          updateStatus(`Error searching cards: ${error.message}`);
          searchResults.style.display = "none"; // Hide on error
        } finally {
          removeLoadingIndicator();
          searchAbortController = null;
        }
      }

      async function getCardDataByName(cardName) {
        // This function remains available but isn't the primary way cards are added anymore
        const apiUrl = `https://api.scryfall.com/cards/named?exact=${encodeURIComponent(
          cardName
        )}`;
        try {
          const response = await fetch(apiUrl);
          if (!response.ok) throw new Error(`API error ${response.status}`);
          return await response.json();
        } catch (error) {
          console.error("Error fetching card data by name:", error);
          return null;
        }
      }

      const debouncedLiveSearch = debounce(performLiveSearch, 350);

      // --- Display Logic ---
      function displaySearchResults(cards) {
        searchResults.innerHTML = "";
        if (!cards || cards.length === 0) {
          updateStatus("No cards found.");
          searchResults.style.display = "none";
          return;
        }

        updateStatus(`${cards.length} result(s) shown. Click to add.`);
        searchResults.style.display = "block"; // Show results list

        cards.forEach((card) => {
          const li = document.createElement("li");
          const imageUrl =
            card.image_uris?.small || card.image_uris?.normal || "";
          li.innerHTML = `
                  <img src="${escapeHtml(imageUrl)}" alt="${escapeHtml(
            card.name
          )}" class="search-result-image" loading="lazy">
                  <span class="search-result-name">${escapeHtml(
                    card.name
                  )}</span>
              `;
          li.dataset.cardname = card.name;
          li.dataset.imageurl = imageUrl;
          searchResults.appendChild(li);
        });
      }

      function renderDeck() {
        deckList.innerHTML = "";
        let totalCards = 0;
        const sortedCardNames = Object.keys(currentDeck).sort();

        sortedCardNames.forEach((cardName) => {
          const cardInfo = currentDeck[cardName];
          if (!cardInfo || cardInfo.quantity <= 0) {
            // Ensure we don't render cards with 0 or negative quantity if data gets corrupted
            if (cardInfo) delete currentDeck[cardName]; // Clean up bad entry
            return;
          }
          totalCards += cardInfo.quantity;
          const li = document.createElement("li");
          li.innerHTML = `
                      <div class="card-info">
                          <img src="${escapeHtml(
                            cardInfo.imageUrl || ""
                          )}" alt="${escapeHtml(
            cardName
          )}" class="card-image" loading="lazy">
                          <span class="card-name" title="${escapeHtml(
                            cardName
                          )}">${escapeHtml(cardName)}</span>
                      </div>
                      <div class="card-controls">
                          <span class="card-quantity">
                              <input type="number" min="1" value="${
                                cardInfo.quantity
                              }" data-cardname="${escapeHtml(
            cardName
          )}" class="quantity-input">
                          </span>
                          <button class="delete-card-btn" data-cardname="${escapeHtml(
                            cardName
                          )}">X</button>
                      </div>
                  `;
          deckList.appendChild(li);
        });
        deckTotalCountSpan.textContent = totalCards;
        deckTotalCountBottomSpan.textContent = totalCards;
      }

      // Renders the cards currently in the hand zone
      function displayHand() {
        const handList = document.getElementById("testHandDisplay");
        handList.innerHTML = ""; // Clear current hand display

        currentHand.sort((a, b) => a.name.localeCompare(b.name)); // Sort hand for consistency

        currentHand.forEach((card) => {
          const li = document.createElement("li");
          li.dataset.handId = card.handId; // Store unique hand ID
          li.innerHTML = `
                  <div class="card-info">
                      <img src="${escapeHtml(
                        card.imageUrl || ""
                      )}" alt="${escapeHtml(
            card.name
          )}" class="card-image" loading="lazy">
                      <span class="card-name" title="${escapeHtml(
                        card.name
                      )}">${escapeHtml(card.name)}</span>
                  </div>
              `;
          li.addEventListener("click", handlePlayCardFromHand); // Add click listener to move
          handList.appendChild(li);
        });

        handCardCountSpan.textContent = currentHand.length;
      }

      // Renders the cards currently on the battlefield zone
      function displayBattlefield() {
        const battlefield = document.getElementById("battlefieldDisplay");
        battlefield.innerHTML = ""; // Clear current battlefield display

        Object.entries(currentBattlefield).forEach(([id, card]) => {
          const cardDiv = document.createElement("div");
          cardDiv.classList.add("battlefield-card");
          cardDiv.dataset.battlefieldId = id;
          cardDiv.draggable = true;
          // Ensure x/y are numbers before setting style
          const posX = typeof card.x === "number" ? card.x : 10;
          const posY = typeof card.y === "number" ? card.y : 10;
          cardDiv.style.left = `${posX}px`;
          cardDiv.style.top = `${posY}px`;
          cardDiv.innerHTML = `
                  <img src="${escapeHtml(
                    card.imageUrl || ""
                  )}" alt="${escapeHtml(card.name)}" title="${escapeHtml(
            card.name
          )}">
              `;
          // Add drag event listeners directly to the card element
          cardDiv.addEventListener("dragstart", handleDragStart);
          cardDiv.addEventListener("dragend", handleDragEnd);

          battlefield.appendChild(cardDiv);
        });
      }

      // --- Deck Management Logic ---
      function addCardToDeck(cardName, imageUrl) {
        const existingCard = currentDeck[cardName];

        if (existingCard) {
          existingCard.quantity++;
          updateDeckActionStatus(
            `Incremented "${cardName}" to ${existingCard.quantity}.`
          );
        } else {
          // Ensure imageUrl is a string, provide a placeholder if missing
          const safeImageUrl = typeof imageUrl === "string" ? imageUrl : "";
          if (!imageUrl) {
            console.warn(
              `Missing image URL for card: ${cardName}. Using placeholder logic if needed.`
            );
            // Optionally add a placeholder image URL here
          }

          currentDeck[cardName] = {
            quantity: 1,
            imageUrl: safeImageUrl,
          };
          updateDeckActionStatus(`Added "${cardName}" to deck.`);
        }
        renderDeck();

        // Clear search input and results after adding
        searchInput.value = "";
        searchResults.innerHTML = "";
        searchResults.style.display = "none";
        clearStatus();
      }

      function updateCardQuantity(cardName, newQuantity) {
        const quantity = parseInt(newQuantity, 10);
        const cardInfo = currentDeck[cardName];
        if (!cardInfo) return;

        if (isNaN(quantity) || quantity <= 0) {
          // Treat 0 or invalid input as deletion
          deleteCardFromDeck(cardName); // This already calls renderDeck
          updateDeckActionStatus(`Removed "${cardName}" (invalid quantity).`);
        } else {
          cardInfo.quantity = quantity;
          updateDeckActionStatus(
            `Updated "${cardName}" quantity to ${quantity}.`
          );
          renderDeck();
        }
      }

      function deleteCardFromDeck(cardName) {
        if (currentDeck[cardName]) {
          delete currentDeck[cardName];
          updateDeckActionStatus(`Removed "${cardName}" from deck.`);
          renderDeck(); // Update deck display
          // Note: This doesn't affect a currently drawn hand/battlefield
        }
      }

      function clearDeck() {
        if (
          confirm(
            "Are you sure you want to clear the current deck? This also clears the test area. This cannot be undone unless saved."
          )
        ) {
          currentDeck = {};
          updateDeckActionStatus("Deck cleared.");
          renderDeck();
          clearTestHand(); // Clear the test area as well
        }
      }

      // --- Local Storage ---
      function saveDeck() {
        try {
          localStorage.setItem(DECK_STORAGE_KEY, JSON.stringify(currentDeck));
          updateDeckActionStatus("Deck saved successfully!");
        } catch (error) {
          console.error("Error saving deck:", error);
          updateDeckActionStatus(
            "Error saving deck. LocalStorage might be full or disabled."
          );
        }
      }

      function loadDeck() {
        const savedDeck = localStorage.getItem(DECK_STORAGE_KEY);
        if (savedDeck) {
          try {
            const parsedDeck = JSON.parse(savedDeck);
            // Basic validation
            if (
              typeof parsedDeck === "object" &&
              parsedDeck !== null &&
              !Array.isArray(parsedDeck)
            ) {
              let isValid = true;
              for (const key in parsedDeck) {
                if (
                  typeof parsedDeck[key] !== "object" ||
                  parsedDeck[key] === null ||
                  typeof parsedDeck[key].quantity !== "number" ||
                  parsedDeck[key].quantity <= 0 || // Ensure quantity is positive
                  typeof parsedDeck[key].imageUrl !== "string"
                ) {
                  isValid = false;
                  console.warn(
                    `Invalid entry found for key: ${key}`,
                    parsedDeck[key]
                  );
                  break;
                }
              }

              if (isValid) {
                currentDeck = parsedDeck;
                updateDeckActionStatus("Deck loaded successfully!");
                renderDeck();
                clearTestHand(); // Clear test area when loading a new deck
              } else {
                updateDeckActionStatus(
                  "Failed to load deck: Invalid data format in storage."
                );
                currentDeck = {}; // Reset deck if loaded data is bad
                renderDeck();
                clearTestHand();
                console.warn(
                  "Invalid deck structure found in localStorage, deck reset.",
                  parsedDeck
                );
              }
            } else {
              updateDeckActionStatus(
                "Failed to load deck: Invalid data type in storage."
              );
              currentDeck = {}; // Reset deck if loaded data is bad
              renderDeck();
              clearTestHand();
              console.warn(
                "Invalid data type found in localStorage:",
                parsedDeck
              );
            }
          } catch (error) {
            console.error("Error parsing saved deck:", error);
            updateDeckActionStatus(
              "Error loading deck: Could not parse saved data."
            );
            currentDeck = {}; // Reset deck on parsing error
            renderDeck();
            clearTestHand();
          }
        } else {
          updateDeckActionStatus("No saved deck found.");
          // Ensure deck is empty if nothing is loaded
          if (Object.keys(currentDeck).length > 0) {
            currentDeck = {};
            renderDeck();
            clearTestHand();
          }
        }
      }

      // --- Test Hand / Play Area Logic ---
      function drawTestHand() {
        // Clear previous test state
        clearTestHand(); // Clears hand, battlefield, counters, status

        const deckArray = [];
        for (const cardName in currentDeck) {
          const cardInfo = currentDeck[cardName];
          if (cardInfo && cardInfo.quantity > 0) {
            // Ensure card exists and has quantity
            for (let i = 0; i < cardInfo.quantity; i++) {
              // Store name and URL together
              deckArray.push({ name: cardName, imageUrl: cardInfo.imageUrl });
            }
          }
        }

        const deckSize = deckArray.length;
        if (deckSize < 7) {
          testHandStatus.textContent = `Cannot draw hand: Deck only has ${deckSize} cards (needs at least 7).`;
          return;
        }

        // Shuffle the deck array (Fisher-Yates)
        for (let i = deckArray.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [deckArray[i], deckArray[j]] = [deckArray[j], deckArray[i]];
        }

        // Draw the top 7 cards
        const hand = deckArray.slice(0, 7);

        // Populate currentHand with unique IDs
        currentHand = hand.map((card) => ({
          handId: handCardIdCounter++,
          name: card.name,
          imageUrl: card.imageUrl,
        }));

        testHandStatus.textContent = `Drew 7 cards. Click a card in hand to play it. Drag cards on battlefield.`;
        displayHand(); // Render the hand
        displayBattlefield(); // Render the (initially empty) battlefield
      }

      // Renamed and updated to clear the entire test area state
      function clearTestHand() {
        currentHand = [];
        currentBattlefield = {};
        handCardIdCounter = 0; // Reset IDs
        battlefieldCardIdCounter = 0;
        dragInfo = { cardId: null, offsetX: 0, offsetY: 0 }; // Reset drag info

        // Clear displays
        if (testHandDisplay) testHandDisplay.innerHTML = "";
        if (battlefieldDisplay) battlefieldDisplay.innerHTML = "";
        if (handCardCountSpan) handCardCountSpan.textContent = "0";
        if (testHandStatus) testHandStatus.textContent = ""; // Clear status message
      }

      // Handles clicking a card in the hand list
      function handlePlayCardFromHand(event) {
        const listItem = event.currentTarget; // Get the LI element that was clicked
        const handId = parseInt(listItem.dataset.handId, 10);

        const cardIndex = currentHand.findIndex(
          (card) => card.handId === handId
        );
        if (cardIndex > -1) {
          const [cardToPlay] = currentHand.splice(cardIndex, 1); // Remove from hand array

          // Add to battlefield state
          const battlefieldId = `bf-${battlefieldCardIdCounter++}`;
          // Add some randomness to initial placement to avoid exact stacking
          const initialX = 10 + Math.floor(Math.random() * 30);
          const initialY = 10 + Math.floor(Math.random() * 30);

          currentBattlefield[battlefieldId] = {
            name: cardToPlay.name,
            imageUrl: cardToPlay.imageUrl,
            x: initialX,
            y: initialY,
          };

          // Re-render both zones
          displayHand();
          displayBattlefield();
        }
      }

      // --- Drag and Drop Handlers ---
      function handleDragStart(event) {
        const cardElement = event.target.closest(".battlefield-card");
        if (!cardElement) return;

        const cardId = cardElement.dataset.battlefieldId;
        if (!cardId) return;

        dragInfo.cardId = cardId;

        // Calculate offset from cursor to top-left corner of the card
        const rect = cardElement.getBoundingClientRect();
        dragInfo.offsetX = event.clientX - rect.left;
        dragInfo.offsetY = event.clientY - rect.top;

        // Set data for the drag operation (needed for Firefox)
        event.dataTransfer.setData("text/plain", cardId);
        event.dataTransfer.effectAllowed = "move";

        // Optional: Add styling to the image inside the card div
        setTimeout(
          () => cardElement.querySelector("img")?.classList.add("dragging"),
          0
        );
        event.stopPropagation(); // Prevent event bubbling
      }

      function handleDragEnd(event) {
        // Clean up styling regardless of drop success
        const cardId = dragInfo.cardId; // Get id from dragInfo as event.target might be unreliable
        if (cardId) {
          const cardElement = battlefieldDisplay.querySelector(
            `[data-battlefield-id="${cardId}"]`
          );
          if (cardElement) {
            cardElement.querySelector("img")?.classList.remove("dragging");
          }
        }
        dragInfo.cardId = null; // Reset drag info
        dragInfo.offsetX = 0;
        dragInfo.offsetY = 0;
        // No stopPropagation needed here usually
      }

      function handleDragOver(event) {
        event.preventDefault(); // Necessary to allow dropping
        event.dataTransfer.dropEffect = "move";
        // No stopPropagation needed here usually
      }

      function handleDrop(event) {
        event.preventDefault(); // Prevent default drop behavior
        const battlefieldZone = event.currentTarget; // The #battlefieldDisplay div
        const draggedCardId = dragInfo.cardId; // Use reliable dragInfo

        if (!draggedCardId || !currentBattlefield[draggedCardId]) {
          console.warn(
            "Drop failed: Could not identify dragged card ID or card not in state."
          );
          dragInfo.cardId = null; // Reset just in case
          return; // Card ID not found or invalid
        }

        const cardElement = battlefieldZone.querySelector(
          `[data-battlefield-id="${draggedCardId}"]`
        );
        if (!cardElement) {
          console.warn(
            "Drop failed: Could not find card element on battlefield."
          );
          dragInfo.cardId = null; // Reset just in case
          return;
        }

        // Calculate drop position relative to the battlefield container
        const battlefieldRect = battlefieldZone.getBoundingClientRect();
        let newX = event.clientX - battlefieldRect.left - dragInfo.offsetX;
        let newY = event.clientY - battlefieldRect.top - dragInfo.offsetY;

        // --- Boundary Checks (Keep card within battlefield) ---
        const cardWidth = cardElement.offsetWidth; // Use offsetWidth
        const cardHeight = cardElement.offsetHeight; // Use offsetHeight
        const containerWidth = battlefieldZone.clientWidth; // Use clientWidth
        const containerHeight = battlefieldZone.clientHeight; // Use clientHeight

        // Ensure left edge is not less than 0
        newX = Math.max(0, newX);
        // Ensure top edge is not less than 0
        newY = Math.max(0, newY);
        // Ensure right edge doesn't go past container width
        newX = Math.min(newX, containerWidth - cardWidth);
        // Ensure bottom edge doesn't go past container height
        newY = Math.min(newY, containerHeight - cardHeight);
        // Ensure values are not negative if container/card dimensions are weird
        newX = Math.max(0, newX);
        newY = Math.max(0, newY);
        // --- End Boundary Checks ---

        // Update the element's position directly
        cardElement.style.left = `${newX}px`;
        cardElement.style.top = `${newY}px`;

        // Update the position in the state object
        currentBattlefield[draggedCardId].x = newX;
        currentBattlefield[draggedCardId].y = newY;

        // Reset drag info handled by dragend
        event.stopPropagation(); // Prevent event bubbling up further
      }

      // --- Event Listeners ---

      // Search Input
      searchInput.addEventListener("input", (event) => {
        const query = event.target.value.trim();
        debouncedLiveSearch(query); // Use debounced search
      });

      // Clicking Search Results
      searchResults.addEventListener("click", (event) => {
        const listItem = event.target.closest("li");
        if (listItem && listItem.dataset.cardname) {
          const cardName = listItem.dataset.cardname;
          const imageUrl = listItem.dataset.imageurl;
          addCardToDeck(cardName, imageUrl);
        }
      });

      // Clicking Outside Search
      document.addEventListener("click", (event) => {
        const searchSection = document.querySelector(".search-section");
        // Check if the click was outside the search section AND outside the results list
        if (
          !searchSection.contains(event.target) &&
          !searchResults.contains(event.target)
        ) {
          searchResults.innerHTML = "";
          searchResults.style.display = "none"; // Hide it
          // clearStatus(); // Keep status message if needed
        }
      });
      // Prevent clicks *inside* the search results list from closing it
      searchResults.addEventListener("click", (event) => {
        event.stopPropagation();
      });

      // Enter Key in Search Input
      searchInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          const firstResult = searchResults.querySelector("li");
          if (firstResult && firstResult.dataset.cardname) {
            const cardName = firstResult.dataset.cardname;
            const imageUrl = firstResult.dataset.imageurl;
            addCardToDeck(cardName, imageUrl);
          } else {
            // If no results are visible, trigger a non-debounced search immediately
            performLiveSearch(searchInput.value.trim());
          }
        }
      });

      // Deck List Interactions (Delete / Quantity Change)
      deckList.addEventListener("click", (event) => {
        if (event.target.classList.contains("delete-card-btn")) {
          const cardName = event.target.getAttribute("data-cardname");
          if (cardName) {
            deleteCardFromDeck(cardName);
          }
        }
      });
      deckList.addEventListener("change", (event) => {
        if (event.target.classList.contains("quantity-input")) {
          const cardName = event.target.getAttribute("data-cardname");
          const newQuantity = event.target.value; // Value is string
          if (cardName) {
            updateCardQuantity(cardName, newQuantity);
          }
        }
      });

      // Action Buttons
      saveDeckButton.addEventListener("click", saveDeck);
      loadDeckButton.addEventListener("click", loadDeck);
      clearDeckButton.addEventListener("click", clearDeck);
      drawHandButton.addEventListener("click", drawTestHand);

      // Drag Listeners for Battlefield Container
      battlefieldDisplay.addEventListener("dragover", handleDragOver);
      battlefieldDisplay.addEventListener("drop", handleDrop);

      // --- Initial Load ---
      document.addEventListener("DOMContentLoaded", () => {
        loadDeck(); // Attempt to load saved deck
        // If loadDeck resulted in an empty deck (or no saved deck existed),
        // currentDeck will be {}, so no need for explicit check here.
        // loadDeck already calls clearTestHand if needed.
        if (Object.keys(currentDeck).length === 0) {
          updateDeckActionStatus("Create a new deck or load a saved one.");
          // Ensure test area is clear if starting fresh
          clearTestHand();
        }
        renderDeck(); // Render the initial deck state (could be empty or loaded)
        // Hand/Battlefield are cleared by loadDeck or clearTestHand and only rendered on Draw
      });
    </script>
  </body>
</html>
