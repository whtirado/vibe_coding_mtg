<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simple MTG Deck Builder (w/ Play Area)</title>
    <style>
      :root {
        --body-bg: #f0f2f5;
        --section-bg: #ffffff;
        --text-color-primary: #333333;
        --text-color-secondary: #444444;
        --text-color-muted: #555555;
        --text-color-link: #007bff;
        --border-color-light: #eeeeee;
        --border-color-medium: #cccccc;
        --border-color-dark: #aaaaaa;
        --button-bg: #007bff;
        --button-text: #ffffff;
        --button-bg-hover: #0056b3;
        --button-disabled-bg: #cccccc;
        --button-disabled-text: #666666;
        --button-delete-bg: #dc3545;
        --button-delete-text: #ffffff;
        --button-delete-bg-hover: #c82333;
        --input-bg: #ffffff;
        --input-border: #cccccc;
        --input-text: #333333;
        --list-item-hover-bg: #f0f8ff;
        --search-result-hover-bg: #f0f0f0;
        --battlefield-bg: #e0e0e0;
        --battlefield-border: #cccccc;
        --zone-general-bg: #e9f5e9;
        --zone-general-border: #9ccc9c;
        --zone-side-bg: #f0f0f0;
        --zone-side-border: #aaaaaa;
        --hand-container-bg: #f9f9f9;
        --hand-card-bg: #ffffff;
        --hand-card-border: #dddddd;
        --hand-card-hover-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        --shadow-color: rgba(0, 0, 0, 0.1);
        --shadow-color-heavy: rgba(0, 0, 0, 0.3);
        --slider-bg: #ccc;
        --slider-knob-bg: white;
        --slider-checked-bg: #007bff;
        --context-menu-bg: #ffffff;
        --context-menu-border: #cccccc;
        --context-menu-text: #333333;
        --context-menu-hover-bg: #f0f0f0;
        --context-menu-disabled-text: #aaaaaa;
        --scry-overlay-bg: rgba(0, 0, 0, 0.75);
        --scry-modal-bg: #ffffff;
        --scry-card-bg: #f9f9f9;
        --scry-card-border: #dddddd;
        --scry-button-bg: #6c757d;
        --scry-button-text: #ffffff;
        --scry-button-hover-bg: #5a6268;
        --scry-button-selected-bg: #0056b3;
        --card-view-overlay-bg: rgba(0, 0, 0, 0.8);
        --card-view-bg: #ffffff;
        --card-view-border: #cccccc;
        --card-view-close-bg: #6c757d;
        --card-view-close-text: #ffffff;
        --card-view-close-hover-bg: #5a6268;
      }

      body[data-theme="dark"] {
        --body-bg: #1a1a1a;
        --section-bg: #2c2c2c;
        --text-color-primary: #e0e0e0;
        --text-color-secondary: #cccccc;
        --text-color-muted: #aaaaaa;
        --text-color-link: #4dabf7;
        --border-color-light: #444444;
        --border-color-medium: #666666;
        --border-color-dark: #888888;
        --button-bg: #0056b3;
        --button-text: #ffffff;
        --button-bg-hover: #003d80;
        --button-disabled-bg: #555555;
        --button-disabled-text: #aaaaaa;
        --button-delete-bg: #a02c38;
        --button-delete-text: #ffffff;
        --button-delete-bg-hover: #80232e;
        --input-bg: #3a3a3a;
        --input-border: #666666;
        --input-text: #e0e0e0;
        --list-item-hover-bg: #3a4a5a;
        --search-result-hover-bg: #444444;
        --battlefield-bg: #3a3a3a;
        --battlefield-border: #666666;
        --zone-general-bg: #2a4a2a;
        --zone-general-border: #5c8c5c;
        --zone-side-bg: #444444;
        --zone-side-border: #777777;
        --hand-container-bg: #252525;
        --hand-card-bg: #383838;
        --hand-card-border: #505050;
        --hand-card-hover-shadow: 0 2px 8px rgba(255, 255, 255, 0.15);
        --shadow-color: rgba(255, 255, 255, 0.05);
        --shadow-color-heavy: rgba(255, 255, 255, 0.15);
        --slider-bg: #555;
        --slider-knob-bg: #bbb;
        --slider-checked-bg: #0056b3;
        --context-menu-bg: #3a3a3a;
        --context-menu-border: #666666;
        --context-menu-text: #e0e0e0;
        --context-menu-hover-bg: #444444;
        --context-menu-disabled-text: #888888;
        --scry-overlay-bg: rgba(0, 0, 0, 0.85);
        --scry-modal-bg: #2c2c2c;
        --scry-card-bg: #383838;
        --scry-card-border: #505050;
        --scry-button-bg: #5a6268;
        --scry-button-text: #ffffff;
        --scry-button-hover-bg: #495057;
        --scry-button-selected-bg: #003d80;
        --card-view-overlay-bg: rgba(0, 0, 0, 0.9);
        --card-view-bg: #3a3a3a;
        --card-view-border: #666666;
        --card-view-close-bg: #5a6268;
        --card-view-close-text: #ffffff;
        --card-view-close-hover-bg: #495057;
      }

      body {
        font-family: sans-serif;
        display: grid;
        grid-template-columns: 1fr 2fr;
        grid-template-rows: auto auto auto 1fr;
        gap: 20px;
        max-width: 1400px;
        margin: 20px auto;
        padding: 15px;
        background-color: var(--body-bg);
        color: var(--text-color-primary);
        transition: background-color 0.3s ease, color 0.3s ease;
      }

      .header-container {
        grid-column: 1 / -1;
        grid-row: 1 / 2;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        margin-bottom: 15px;
      }
      h1 {
        text-align: center;
        color: var(--text-color-primary);
        margin: 0;
      }

      .theme-switch-wrapper {
        display: flex;
        align-items: center;
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
      }
      .theme-switch {
        display: inline-block;
        height: 24px;
        position: relative;
        width: 44px;
      }
      .theme-switch input {
        display: none;
      }
      .slider {
        background-color: var(--slider-bg);
        bottom: 0;
        cursor: pointer;
        left: 0;
        position: absolute;
        right: 0;
        top: 0;
        transition: 0.4s;
        border-radius: 24px;
      }
      .slider:before {
        background-color: var(--slider-knob-bg);
        bottom: 3px;
        content: "";
        height: 18px;
        left: 3px;
        position: absolute;
        transition: 0.4s;
        width: 18px;
        border-radius: 50%;
      }
      input:checked + .slider {
        background-color: var(--slider-checked-bg);
      }
      input:checked + .slider:before {
        transform: translateX(20px);
      }

      .search-section h2,
      .deck-section h2,
      .actions-section h2,
      .test-hand-section h2 {
        text-align: center;
        color: var(--text-color-primary);
        margin-bottom: 15px;
      }
      h3 {
        margin-top: 0;
        margin-bottom: 10px;
        color: var(--text-color-secondary);
        font-size: 1em;
        padding: 0 5px;
      }
      h4 {
        margin: 5px 0;
        font-size: 0.9em;
        color: var(--text-color-muted);
        text-align: center;
        border-bottom: 1px solid var(--border-color-light);
        padding-bottom: 3px;
        width: 100%;
      }
      .search-section,
      .deck-section,
      .actions-section,
      .test-hand-section {
        background-color: var(--section-bg);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 5px var(--shadow-color);
        display: flex;
        flex-direction: column;
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }

      .search-section {
        grid-column: 1 / 2;
        grid-row: 2 / 3;
        position: relative;
      }
      .actions-section {
        grid-column: 1 / 2;
        grid-row: 3 / 4;
      }
      .deck-section {
        grid-column: 2 / 3;
        grid-row: 2 / 4;
      }
      .test-hand-section {
        grid-column: 1 / -1;
        grid-row: 4 / 5;
        min-height: 750px;
      }

      #searchInput {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        border: 1px solid var(--input-border);
        border-radius: 4px;
        box-sizing: border-box;
        background-color: var(--input-bg);
        color: var(--input-text);
      }
      #searchResults {
        list-style: none;
        padding: 0;
        margin: 10px 0 0 0;
        max-height: 180px;
        overflow-y: auto;
        border: 1px solid var(--border-color-light);
        border-radius: 4px;
        background-color: var(--section-bg);
        z-index: 10;
        box-shadow: 0 4px 6px var(--shadow-color);
      }
      #searchResults li {
        padding: 5px 10px;
        cursor: pointer;
        border-bottom: 1px solid var(--border-color-light);
        display: flex;
        align-items: center;
        gap: 8px;
      }
      #searchResults li:last-child {
        border-bottom: none;
      }
      #searchResults li:hover {
        background-color: var(--search-result-hover-bg);
      }
      .search-result-image {
        width: 30px;
        height: auto;
        border-radius: 2px;
        flex-shrink: 0;
      }
      .search-result-name {
        font-size: 0.9em;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      #searchResults:empty {
        border: none;
        box-shadow: none;
        max-height: 0;
        margin-top: 0;
      }

      #deckList {
        list-style: none;
        padding: 0;
        margin-top: 10px;
        max-height: 500px;
        overflow-y: auto;
        flex-grow: 1;
      }
      #deckList li {
        padding: 8px 5px;
        border-bottom: 1px solid var(--border-color-light);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
      }
      #deckList li:last-child {
        border-bottom: none;
      }
      .card-info {
        display: flex;
        align-items: center;
        gap: 8px;
        flex-grow: 1;
        min-width: 0;
      }
      .card-image {
        width: 60px;
        height: auto;
        border-radius: 3px;
        vertical-align: middle;
        flex-shrink: 0;
        cursor: default;
      }
      .card-name {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .card-controls {
        display: flex;
        align-items: center;
        gap: 5px;
        flex-shrink: 0;
      }
      .card-quantity input {
        width: 40px;
        text-align: center;
        padding: 4px;
        border: 1px solid var(--input-border);
        border-radius: 3px;
        background-color: var(--input-bg);
        color: var(--input-text);
      }
      .action-button,
      .delete-card-btn,
      #drawHandButton,
      #drawNextCardButton,
      #shuffleDeckButton,
      #searchDeckButton,
      #scryButton,
      #untapAllButton {
        /* Added untapAllButton */
        padding: 9px 15px;
        background-color: var(--button-bg);
        color: var(--button-text);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        font-size: 0.9em;
        margin-bottom: 10px;
      }
      .test-controls {
        margin-bottom: 10px;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
      }
      .test-controls .action-button,
      .test-controls {
        display: inline-block;
        width: auto;
        margin-right: 10px;
        margin-bottom: 5px;
      }
      .scry-control {
        display: inline-flex;
        align-items: center;
        gap: 5px;
      }
      #scryCountInput {
        width: 45px;
        padding: 8px 5px;
        text-align: center;
        border: 1px solid var(--input-border);
        border-radius: 4px;
        background-color: var(--input-bg);
        color: var(--input-text);
        font-size: 0.9em;
        margin-bottom: 10px;
      }

      #testHandStatus {
        flex-grow: 1;
        margin-left: 10px;
        margin-top: 0;
        min-height: initial;
        margin-bottom: 5px;
        font-size: 0.9em;
        color: var(--text-color-muted);
      }
      .action-button:hover,
      .delete-card-btn:hover,
      #drawHandButton:hover,
      #drawNextCardButton:hover,
      #shuffleDeckButton:hover,
      #searchDeckButton:hover,
      #scryButton:hover,
      #untapAllButton:hover {
        /* Added untapAllButton */
        background-color: var(--button-bg-hover);
      }
      .action-button:disabled,
      #drawNextCardButton:disabled,
      #shuffleDeckButton:disabled,
      #searchDeckButton:disabled,
      #scryButton:disabled,
      #untapAllButton:disabled {
        /* Added untapAllButton */
        background-color: var(--button-disabled-bg);
        color: var(--button-disabled-text);
        cursor: not-allowed;
      }
      .delete-card-btn {
        background-color: var(--button-delete-bg);
        color: var(--button-delete-text);
        padding: 4px 8px;
        font-size: 0.8em;
        line-height: 1;
        margin-bottom: 0;
      }
      .delete-card-btn:hover {
        background-color: var(--button-delete-bg-hover);
      }
      .actions-section .action-button {
        display: block;
        width: 100%;
      }
      #status,
      #deckActionStatus {
        margin-top: 10px;
        font-style: italic;
        color: var(--text-color-muted);
        min-height: 1.2em;
        font-size: 0.9em;
      }
      #deckCount {
        text-align: right;
        font-weight: 700;
        margin-top: 15px;
        padding-top: 10px;
        border-top: 1px solid var(--border-color-light);
      }
      .loading::after {
        content: " Loading...";
        display: inline-block;
        margin-left: 5px;
        font-style: italic;
        color: var(--text-color-muted);
        font-size: 0.9em;
      }

      .play-area-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 10px;
        border-top: 1px solid var(--border-color-light);
        padding-top: 15px;
        flex-grow: 1;
        overflow: hidden;
      }
      .battlefield-and-side-zones {
        display: flex;
        gap: 15px;
        flex-grow: 1;
        min-height: 400px;
      }
      .battlefield-zone {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        background-color: var(--battlefield-bg);
        border: 1px solid var(--battlefield-border);
        border-radius: 5px;
        padding: 10px;
        overflow: hidden;
      }
      #generalZone {
        flex-grow: 1;
        border-radius: 4px;
        padding: 10px 5px 5px 5px;
        position: relative;
        min-height: 350px;
        overflow: auto;
        display: flex;
        flex-wrap: wrap;
        align-content: flex-start;
        gap: 5px;
        background-color: var(--zone-general-bg);
        border: 1px dashed var(--zone-general-border);
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }
      .side-zones {
        display: flex;
        flex-direction: column;
        gap: 10px;
        flex-shrink: 0;
        width: 140px;
      }
      #graveyardZone,
      #exileZone {
        flex-basis: 50%;
        flex-grow: 1;
        border-radius: 4px;
        padding: 5px;
        position: relative;
        min-height: 200px;
        max-height: 200px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        background-color: var(--zone-side-bg);
        border: 1px dashed var(--zone-side-border);
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }
      #graveyardZone h4,
      #exileZone h4 {
        margin-bottom: 5px;
        font-size: 0.85em;
        width: auto;
        border-bottom: none;
        padding-bottom: 0;
      }

      #testHandContainer {
        flex-shrink: 0;
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        padding: 15px 10px;
        background-color: var(--hand-container-bg);
        border: 1px solid var(--border-color-medium);
        border-radius: 5px;
        min-height: 120px;
        overflow-y: auto;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }
      .hand-card {
        width: 100px;
        height: auto;
        border-radius: 4px;
        box-shadow: 1px 1px 3px var(--shadow-color);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        overflow: hidden;
      }
      .hand-card:hover {
        transform: translateY(-3px) scale(1.03);
        box-shadow: var(--hand-card-hover-shadow);
      }
      .hand-card img {
        display: block;
        width: 100%;
        height: auto;
      }
      .battlefield-card {
        position: absolute;
        width: 80px;
        height: auto;
        border-radius: 4px;
        box-shadow: 1px 1px 3px var(--shadow-color-heavy);
        cursor: grab;
        user-select: none;
        transition: box-shadow 0.2s ease, transform 0.2s ease-in-out,
          left 0.1s ease-out, top 0.1s ease-out; /* Added transition for position */
        transform-origin: center center;
        background-color: var(--section-bg);
        z-index: 1;
      }
      .battlefield-card.tapped {
        transform: rotate(90deg);
      }
      .battlefield-card:active {
        cursor: grabbing;
        box-shadow: 2px 2px 6px var(--shadow-color-heavy);
        z-index: 1000;
        transition: box-shadow 0.2s ease, transform 0.2s ease-in-out; /* Remove position transition while dragging */
      }
      .battlefield-card img {
        width: 100%;
        height: auto;
        display: block;
        pointer-events: none;
        border-radius: 4px;
      }
      .battlefield-card img.dragging {
        opacity: 0.4;
      }
      .side-zone-card {
        width: 50px;
        height: auto;
        border-radius: 3px;
        margin-bottom: 3px;
        cursor: default;
        box-shadow: 0 1px 2px var(--shadow-color);
        position: relative;
      }
      .side-zone-card img {
        display: block;
        width: 100%;
        height: auto;
        border-radius: 3px;
      }

      #deckSearchArea {
        display: none;
        padding: 10px;
        border: 1px dashed var(--border-color-medium);
        border-radius: 4px;
        margin-top: 10px;
        background-color: var(--zone-side-bg);
        max-height: 300px;
        overflow-y: auto;
        position: relative;
      }
      #deckSearchArea p {
        margin: 0 0 10px 0;
        font-size: 0.9em;
        color: var(--text-color-muted);
        text-align: center;
      }
      #closeSearchAreaButton {
        position: absolute;
        top: 5px;
        right: 5px;
        font-size: 0.8em;
        padding: 3px 8px;
        margin-top: 0;
        z-index: 15;
      }
      #deckSearchResults {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: center;
        overflow-y: visible;
        max-height: none;
        border: none;
        box-shadow: none;
      }
      #deckSearchResults li {
        padding: 0;
        border: none;
        cursor: pointer;
        width: 65px;
        border-radius: 4px;
        overflow: hidden;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        background-color: var(--hand-card-bg);
        border: 1px solid var(--hand-card-border);
        box-shadow: 1px 1px 3px var(--shadow-color);
      }
      #deckSearchResults li:hover {
        transform: translateY(-2px) scale(1.03);
        box-shadow: var(--hand-card-hover-shadow);
      }
      #deckSearchResults li img {
        display: block;
        width: 100%;
        height: auto;
        border-radius: 3px;
      }

      #cardContextMenu {
        position: absolute;
        display: none;
        background-color: var(--context-menu-bg);
        border: 1px solid var(--context-menu-border);
        border-radius: 4px;
        box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.2);
        padding: 5px 0;
        z-index: 10011;
        min-width: 150px;
      }
      #cardContextMenu ul {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      #cardContextMenu li {
        padding: 6px 12px;
        cursor: pointer;
        color: var(--context-menu-text);
        font-size: 0.9em;
        white-space: nowrap;
      }
      #cardContextMenu li:hover:not(.disabled):not(.hidden) {
        background-color: var(--context-menu-hover-bg);
      }
      #cardContextMenu li.disabled {
        color: var(--context-menu-disabled-text);
        cursor: not-allowed;
        background-color: transparent;
      }
      #cardContextMenu li.hidden {
        display: none;
      }

      #scryOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--scry-overlay-bg);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 10010;
        padding: 20px;
        box-sizing: border-box;
      }
      #scryModal {
        background-color: var(--scry-modal-bg);
        padding: 25px;
        border-radius: 8px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        max-width: 90%;
        max-height: 90%;
        overflow-y: auto;
        text-align: center;
      }
      #scryModal h3 {
        margin-top: 0;
        margin-bottom: 20px;
        color: var(--text-color-primary);
      }
      #scryCardContainer {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        justify-content: center;
        margin-bottom: 25px;
      }
      .scry-card-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 10px;
        background-color: var(--scry-card-bg);
        border: 1px solid var(--scry-card-border);
        border-radius: 6px;
        cursor: default;
      }
      .scry-card-item img {
        width: 100px;
        height: auto;
        border-radius: 4px;
        margin-bottom: 5px;
        pointer-events: none;
      }
      .scry-card-item .scry-choice-buttons button {
        padding: 5px 10px;
        font-size: 0.8em;
        margin: 0 4px;
        cursor: pointer;
        border-radius: 3px;
        border: none;
        background-color: var(--scry-button-bg);
        color: var(--scry-button-text);
        transition: background-color 0.2s ease;
      }
      .scry-card-item .scry-choice-buttons button:hover:not(:disabled) {
        background-color: var(--scry-button-hover-bg);
      }
      .scry-card-item .scry-choice-buttons button:disabled {
        background-color: var(--button-disabled-bg);
        color: var(--button-disabled-text);
        cursor: not-allowed;
      }

      #cardViewPopupOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--card-view-overlay-bg);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 10020;
        padding: 20px;
        box-sizing: border-box;
      }
      #cardViewPopupContent {
        position: relative;
        min-width: 30vw;
        max-width: 90vw;
        max-height: 90vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: var(--card-view-bg);
        padding: 10px;
        border-radius: 8px;
        border: 1px solid var(--card-view-border);
        box-shadow: 0 5px 20px var(--shadow-color-heavy);
      }
      #cardViewImage {
        display: block;
        width: 100%;
        max-height: calc(90vh - 60px);
        height: auto;
        border-radius: 25px;
        object-fit: contain;
      }
      #closeCardViewPopupButton {
        position: absolute;
        top: -10px;
        right: -10px;
        background-color: var(--card-view-close-bg);
        color: var(--card-view-close-text);
        border: none;
        border-radius: 50%;
        width: 30px;
        height: 30px;
        font-size: 18px;
        line-height: 30px;
        text-align: center;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        transition: background-color 0.2s ease;
      }
      #closeCardViewPopupButton:hover {
        background-color: var(--card-view-close-hover-bg);
      }
    </style>
  </head>
  <body data-theme="light">
    <div class="header-container">
      <h1>Simple MTG Deck Builder</h1>
      <div class="theme-switch-wrapper">
        <label class="theme-switch" for="themeToggleCheckbox"
          ><input type="checkbox" id="themeToggleCheckbox" /><span
            class="slider round"
          ></span
        ></label>
      </div>
    </div>

    <div class="search-section">
      <h2>Card Search</h2>
      <input
        type="text"
        id="searchInput"
        placeholder="Start typing card name..."
        autocomplete="off"
      />
      <ul id="searchResults"></ul>
      <div id="status">Type at least 3 characters for suggestions.</div>
    </div>

    <div class="actions-section">
      <h2>Deck Actions</h2>
      <button id="saveDeckButton" class="action-button">Save Deck</button
      ><button id="loadDeckButton" class="action-button">Load Deck</button
      ><button id="clearDeckButton" class="action-button">
        Clear Current Deck
      </button>
      <div id="deckActionStatus"></div>
    </div>

    <div class="deck-section">
      <h2>Current Deck (<span id="deckTotalCount">0</span> cards)</h2>
      <ul id="deckList"></ul>
      <div id="deckCount">Total: <span id="deckTotalCountBottom">0</span></div>
    </div>

    <div class="test-hand-section">
      <h2>Test Area</h2>
      <div class="test-controls">
        <button id="drawHandButton" class="action-button">Draw 7 Cards</button>
        <button id="drawNextCardButton" class="action-button" disabled>
          Draw Next Card
        </button>
        <button id="shuffleDeckButton" class="action-button" disabled>
          Shuffle Library
        </button>
        <button id="searchDeckButton" class="action-button" disabled>
          Search Library
        </button>
        <div class="scry-control">
          <button id="scryButton" class="action-button" disabled>Scry</button>
          <input type="number" id="scryCountInput" value="1" min="1" max="10" />
        </div>
        <button id="untapAllButton" class="action-button" style="display: none">
          Untap All
        </button>
        <span id="testHandStatus"></span>
      </div>

      <div id="deckSearchArea">
        <p>Click a card in the library to add it to your hand:</p>
        <ul id="deckSearchResults"></ul>
        <button id="closeSearchAreaButton" class="action-button">
          Close Search
        </button>
      </div>

      <div class="play-area-container">
        <div class="battlefield-and-side-zones">
          <div class="battlefield-zone" id="battlefieldDisplayContainer">
            <div id="generalZone"><h4>General Battlefield</h4></div>
          </div>
          <div class="side-zones">
            <div id="graveyardZone">
              <h4>Graveyard (<span id="graveyardCount">0</span>)</h4>
            </div>
            <div id="exileZone">
              <h4>Exile (<span id="exileCount">0</span>)</h4>
            </div>
          </div>
        </div>
        <div id="testHandContainer"></div>
      </div>
    </div>

    <div id="cardContextMenu">
      <ul>
        <li data-action="toggleTap">Tap/Untap</li>
        <li data-action="viewCard">View Card</li>
        <li data-action="toHand">Move to Hand</li>
        <li data-action="toBattlefield">Move to Battlefield</li>
        <li data-action="toGraveyard">Move to Graveyard</li>
        <li data-action="toExile">Move to Exile</li>
        <li data-action="toLibraryTop">Move to Library (Top)</li>
        <li data-action="toLibraryBottom">Move to Library (Bottom)</li>
      </ul>
    </div>

    <div id="scryOverlay">
      <div id="scryModal">
        <h3 id="scryModalTitle">Scry X</h3>
        <div id="scryCardContainer"></div>
      </div>
    </div>

    <div id="cardViewPopupOverlay">
      <div id="cardViewPopupContent">
        <img id="cardViewImage" src="" alt="Card Image" />
        <button id="closeCardViewPopupButton">×</button>
      </div>
    </div>

    <script>
      const searchInput = document.getElementById("searchInput");
      const searchResults = document.getElementById("searchResults");
      const statusDiv = document.getElementById("status");
      const deckList = document.getElementById("deckList");
      const deckTotalCountSpan = document.getElementById("deckTotalCount");
      const deckTotalCountBottomSpan = document.getElementById(
        "deckTotalCountBottom"
      );
      const saveDeckButton = document.getElementById("saveDeckButton");
      const loadDeckButton = document.getElementById("loadDeckButton");
      const clearDeckButton = document.getElementById("clearDeckButton");
      const deckActionStatus = document.getElementById("deckActionStatus");
      const drawHandButton = document.getElementById("drawHandButton");
      const drawNextCardButton = document.getElementById("drawNextCardButton");
      const shuffleDeckButton = document.getElementById("shuffleDeckButton");
      const searchDeckButton = document.getElementById("searchDeckButton");
      const scryButton = document.getElementById("scryButton");
      const scryCountInput = document.getElementById("scryCountInput");
      const untapAllButton = document.getElementById("untapAllButton");
      const testHandStatus = document.getElementById("testHandStatus");
      const battlefieldDisplayContainer = document.getElementById(
        "battlefieldDisplayContainer"
      );
      const generalZone = document.getElementById("generalZone");
      const graveyardZone = document.getElementById("graveyardZone");
      const exileZone = document.getElementById("exileZone");
      const graveyardCountSpan = document.getElementById("graveyardCount");
      const exileCountSpan = document.getElementById("exileCount");
      const testHandContainer = document.getElementById("testHandContainer");
      const themeToggle = document.getElementById("themeToggleCheckbox");
      const deckSearchArea = document.getElementById("deckSearchArea");
      const deckSearchResults = document.getElementById("deckSearchResults");
      const closeSearchAreaButton = document.getElementById(
        "closeSearchAreaButton"
      );
      const cardContextMenu = document.getElementById("cardContextMenu");
      const scryOverlay = document.getElementById("scryOverlay");
      const scryModal = document.getElementById("scryModal");
      const scryModalTitle = document.getElementById("scryModalTitle");
      const scryCardContainer = document.getElementById("scryCardContainer");
      const cardViewPopupOverlay = document.getElementById(
        "cardViewPopupOverlay"
      );
      const cardViewImage = document.getElementById("cardViewImage");
      const closeCardViewPopupButton = document.getElementById(
        "closeCardViewPopupButton"
      );

      const DECK_STORAGE_KEY = "mtgDeckBuilderSimpleDeckV3";
      const THEME_STORAGE_KEY = "mtgThemePreference";

      let currentDeck = {};
      let searchAbortController = null;
      let currentHand = [];
      let currentBattlefield = {};
      let currentLibrary = [];
      let currentGraveyard = [];
      let currentExile = [];
      let handCardIdCounter = 0;
      let battlefieldCardIdCounter = 0;
      let graveyardCardIdCounter = 0;
      let exileCardIdCounter = 0;
      let dragInfo = { cardId: null, offsetX: 0, offsetY: 0 };
      let contextMenuVisible = false;
      let contextMenuTarget = {
        cardId: null,
        cardData: null,
        sourceZone: null,
      };
      let scryingState = {
        active: false,
        cards: [],
        expectedCount: 0,
        resolvedCount: 0,
        toBottom: [],
      };

      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }
      function updateStatus(message, isLoading = false) {
        statusDiv.textContent = message;
        statusDiv.classList.toggle("loading", isLoading);
      }
      function clearStatus() {
        updateStatus("");
      }
      function removeLoadingIndicator() {
        statusDiv.classList.remove("loading");
      }
      function updateDeckActionStatus(message) {
        deckActionStatus.textContent = message;
        setTimeout(() => {
          if (deckActionStatus.textContent === message)
            deckActionStatus.textContent = "";
        }, 4000);
      }
      function escapeHtml(unsafe) {
        if (unsafe === null || unsafe === undefined) return "";
        return unsafe
          .toString()
          .replace(/&/g, "&")
          .replace(/</g, "<")
          .replace(/>/g, ">")
          .replace(/"/g, '"')
          .replace(/'/g, "'");
      }

      async function performLiveSearch(query) {
        if (searchAbortController) {
          searchAbortController.abort();
        }
        searchAbortController = new AbortController();
        const signal = searchAbortController.signal;
        searchResults.innerHTML = "";
        if (!query || query.length < 3) {
          searchResults.style.display = "none";
          updateStatus("Type at least 3 characters for suggestions.");
          return;
        }
        updateStatus("Searching...", true);
        const apiUrl = `https://api.scryfall.com/cards/search?q=${encodeURIComponent(
          query
        )}&unique=cards&order=name&include_extras=false&include_variations=false`;
        try {
          const response = await fetch(apiUrl, { signal });
          if (!response.ok) {
            if (response.status === 404) {
              updateStatus(`No cards found matching "${escapeHtml(query)}".`);
            } else if (response.status === 400) {
              updateStatus(`Invalid search query. Try different terms.`);
            } else {
              throw new Error(`API Error: ${response.status}`);
            }
            searchResults.style.display = "none";
            return;
          }
          const data = await response.json();
          displaySearchResults(data.data.slice(0, 15));
        } catch (error) {
          if (error.name === "AbortError") {
            console.log("Search fetch aborted");
            return;
          }
          console.error("Search Error:", error);
          updateStatus(`Error searching cards: ${escapeHtml(error.message)}`);
          searchResults.style.display = "none";
        } finally {
          removeLoadingIndicator();
          searchAbortController = null;
        }
      }
      const debouncedLiveSearch = debounce(performLiveSearch, 350);

      function displaySearchResults(cards) {
        searchResults.innerHTML = "";
        if (!cards || cards.length === 0) {
          searchResults.style.display = "none";
          return;
        }
        updateStatus(`${cards.length} result(s) shown. Click to add.`);
        searchResults.style.display = "block";
        cards.forEach((card) => {
          const li = document.createElement("li");
          const smallImageUrl =
            card.image_uris?.small || card.image_uris?.normal || "";
          const normalImageUrl = card.image_uris?.normal || smallImageUrl;
          const cardName = card.name || "Unknown Card";
          li.innerHTML = `<img src="${escapeHtml(
            smallImageUrl
          )}" alt="${escapeHtml(
            cardName
          )}" class="search-result-image" loading="lazy"><span class="search-result-name">${escapeHtml(
            cardName
          )}</span>`;
          li.dataset.cardname = cardName;
          li.dataset.imageurl = smallImageUrl;
          li.dataset.normalimageurl = normalImageUrl;
          searchResults.appendChild(li);
        });
      }
      function renderDeck() {
        deckList.innerHTML = "";
        let totalCards = 0;
        const sortedCardNames = Object.keys(currentDeck).sort();
        sortedCardNames.forEach((cardName) => {
          const cardInfo = currentDeck[cardName];
          if (!cardInfo || cardInfo.quantity <= 0) {
            if (cardInfo) delete currentDeck[cardName];
            return;
          }
          totalCards += cardInfo.quantity;
          const li = document.createElement("li");
          const smallImageUrl = cardInfo.imageUrl || "";
          const normalImageUrl = cardInfo.normalImageUrl || smallImageUrl;
          li.innerHTML = `<div class="card-info"><img src="${escapeHtml(
            smallImageUrl
          )}" alt="${escapeHtml(
            cardName
          )}" class="card-image" loading="lazy" data-normal-src="${escapeHtml(
            normalImageUrl
          )}"><span class="card-name" title="${escapeHtml(
            cardName
          )}">${escapeHtml(
            cardName
          )}</span></div><div class="card-controls"><span class="card-quantity"><input type="number" min="1" value="${
            cardInfo.quantity
          }" data-cardname="${escapeHtml(
            cardName
          )}" class="quantity-input"></span><button class="delete-card-btn" data-cardname="${escapeHtml(
            cardName
          )}">X</button></div>`;
          deckList.appendChild(li);
        });
        deckTotalCountSpan.textContent = totalCards;
        deckTotalCountBottomSpan.textContent = totalCards;
        drawHandButton.disabled = totalCards < 7;
      }
      function displayBattlefield() {
        while (generalZone.children.length > 1) {
          generalZone.removeChild(generalZone.lastChild);
        }
        Object.entries(currentBattlefield).forEach(([id, card]) => {
          if (card.zone === "general") {
            const cardDiv = document.createElement("div");
            cardDiv.classList.add("battlefield-card");
            cardDiv.dataset.battlefieldId = id;
            cardDiv.draggable = true;
            const posX = typeof card.x === "number" ? card.x : 10;
            const posY = typeof card.y === "number" ? card.y : 10;
            cardDiv.style.left = `${posX}px`;
            cardDiv.style.top = `${posY}px`;
            cardDiv.classList.toggle("tapped", card.isTapped);

            const smallImageUrl = card.imageUrl || "";
            const normalImageUrl = card.normalImageUrl || smallImageUrl;
            const safeCardName = card.name || "Unknown Card";
            cardDiv.innerHTML = `<img src="${escapeHtml(
              smallImageUrl
            )}" alt="${escapeHtml(safeCardName)}" title="${escapeHtml(
              safeCardName
            )}" data-normal-src="${escapeHtml(normalImageUrl)}">`;
            cardDiv.addEventListener("dragstart", handleDragStart);
            cardDiv.addEventListener("dragend", handleDragEnd);
            generalZone.appendChild(cardDiv);
          }
        });
        updateUntapAllButtonVisibility();
      }
      function displayHand() {
        testHandContainer.innerHTML = "";
        currentHand.forEach((card) => {
          const cardDiv = document.createElement("div");
          cardDiv.classList.add("hand-card");
          cardDiv.dataset.handId = card.handId;
          const displayImageUrl = card.imageUrl || "";
          const normalImageUrl = card.normalImageUrl || displayImageUrl;
          const safeCardName = card.name || "Unknown Card";
          cardDiv.innerHTML = `<img src="${escapeHtml(
            displayImageUrl
          )}" alt="${escapeHtml(safeCardName)}" title="${escapeHtml(
            safeCardName
          )}" loading="lazy" data-normal-src="${escapeHtml(normalImageUrl)}">`;
          cardDiv.addEventListener("click", handlePlayCardFromHand);
          testHandContainer.appendChild(cardDiv);
        });
        updateTestStatus();
      }
      function displaySideZones() {
        const clearZone = (zone, countSpan) => {
          while (zone.children.length > 1) {
            if (zone.lastChild.nodeName !== "H4") {
              zone.removeChild(zone.lastChild);
            } else {
              break;
            }
          }
          countSpan.textContent = "0";
        };
        clearZone(graveyardZone, graveyardCountSpan);
        clearZone(exileZone, exileCountSpan);
        currentGraveyard.forEach((card) => {
          const cardDiv = document.createElement("div");
          cardDiv.classList.add("side-zone-card");
          cardDiv.dataset.gyId = card.gyId;
          const displayImageUrl = card.imageUrl || "";
          const normalImageUrl = card.normalImageUrl || displayImageUrl;
          const safeCardName = card.name || "Unknown Card";
          cardDiv.innerHTML = `<img src="${escapeHtml(
            displayImageUrl
          )}" alt="${escapeHtml(safeCardName)}" title="${escapeHtml(
            safeCardName
          )}" loading="lazy" data-normal-src="${escapeHtml(normalImageUrl)}">`;
          graveyardZone.appendChild(cardDiv);
        });
        currentExile.forEach((card) => {
          const cardDiv = document.createElement("div");
          cardDiv.classList.add("side-zone-card");
          cardDiv.dataset.exileId = card.exileId;
          const displayImageUrl = card.imageUrl || "";
          const normalImageUrl = card.normalImageUrl || displayImageUrl;
          const safeCardName = card.name || "Unknown Card";
          cardDiv.innerHTML = `<img src="${escapeHtml(
            displayImageUrl
          )}" alt="${escapeHtml(safeCardName)}" title="${escapeHtml(
            safeCardName
          )}" loading="lazy" data-normal-src="${escapeHtml(normalImageUrl)}">`;
          exileZone.appendChild(cardDiv);
        });
        updateTestStatus();
      }

      function updateUntapAllButtonVisibility() {
        let tappedCardExists = false;
        for (const id in currentBattlefield) {
          if (
            currentBattlefield[id].zone === "general" &&
            currentBattlefield[id].isTapped
          ) {
            tappedCardExists = true;
            break;
          }
        }
        untapAllButton.style.display = tappedCardExists
          ? "inline-block"
          : "none";
      }

      function updateTestStatus(message = "") {
        const handCount = currentHand.length;
        const libraryCount = currentLibrary.length;
        const gyCount = currentGraveyard.length;
        const exileCount = currentExile.length;
        graveyardCountSpan.textContent = gyCount;
        exileCountSpan.textContent = exileCount;
        let statusText = message ? `${message} ` : "";
        statusText += `Hand: ${handCount}, Library: ${libraryCount}, GY: ${gyCount}, Exile: ${exileCount}.`;
        const libraryAvailable = libraryCount > 0;
        if (!scryingState.active) {
          drawNextCardButton.disabled = !libraryAvailable;
          shuffleDeckButton.disabled = libraryCount <= 1;
          searchDeckButton.disabled = !libraryAvailable;
          scryButton.disabled = !libraryAvailable;
          scryCountInput.disabled = !libraryAvailable;
          if (libraryAvailable) scryCountInput.max = libraryCount;
          else scryCountInput.max = 1;
        }
        if (!libraryAvailable && !scryingState.active) {
          statusText += " Library is empty.";
        }
        testHandStatus.textContent = statusText;
        updateUntapAllButtonVisibility(); // Ensure button visibility is checked on status updates
      }

      function addCardToDeck(cardName, smallImageUrl, normalImageUrl) {
        if (!cardName) {
          console.error("Attempted to add card with no name.");
          updateDeckActionStatus("Error: Cannot add card without a name.");
          return;
        }
        const existingCard = currentDeck[cardName];
        const safeCardName = escapeHtml(cardName);
        if (existingCard) {
          existingCard.quantity++;
          updateDeckActionStatus(
            `Incremented "${safeCardName}" to ${existingCard.quantity}.`
          );
        } else {
          const safeSmallUrl =
            typeof smallImageUrl === "string" ? smallImageUrl : "";
          const safeNormalUrl =
            typeof normalImageUrl === "string" ? normalImageUrl : safeSmallUrl;
          if (!safeSmallUrl)
            console.warn(`Missing image URL for card: ${safeCardName}.`);
          currentDeck[cardName] = {
            quantity: 1,
            imageUrl: safeSmallUrl,
            normalImageUrl: safeNormalUrl,
          };
          updateDeckActionStatus(`Added "${safeCardName}" to deck.`);
        }
        renderDeck();
        searchInput.value = "";
        searchResults.innerHTML = "";
        searchResults.style.display = "none";
        clearStatus();
      }
      function updateCardQuantity(cardName, newQuantity) {
        const quantity = parseInt(newQuantity, 10);
        const cardInfo = currentDeck[cardName];
        if (!cardInfo) return;
        const safeCardName = escapeHtml(cardName);
        if (isNaN(quantity) || quantity <= 0) {
          deleteCardFromDeck(cardName);
          updateDeckActionStatus(
            `Removed "${safeCardName}" (quantity set to 0 or less).`
          );
        } else {
          cardInfo.quantity = quantity;
          updateDeckActionStatus(
            `Updated "${safeCardName}" quantity to ${quantity}.`
          );
          renderDeck();
        }
      }
      function deleteCardFromDeck(cardName) {
        if (currentDeck[cardName]) {
          const safeCardName = escapeHtml(cardName);
          delete currentDeck[cardName];
          updateDeckActionStatus(`Removed "${safeCardName}" from deck.`);
          renderDeck();
        }
      }
      function clearDeck() {
        if (
          confirm(
            "Are you sure you want to clear the current deck? This also clears the test area. This cannot be undone unless saved."
          )
        ) {
          currentDeck = {};
          updateDeckActionStatus("Deck cleared.");
          renderDeck();
          clearTestArea();
        }
      }

      function saveDeck() {
        try {
          localStorage.setItem(DECK_STORAGE_KEY, JSON.stringify(currentDeck));
          updateDeckActionStatus("Deck saved successfully!");
        } catch (error) {
          console.error("Error saving deck:", error);
          updateDeckActionStatus(
            "Error saving deck. LocalStorage might be full or disabled."
          );
        }
      }
      function loadDeck() {
        const savedDeck = localStorage.getItem(DECK_STORAGE_KEY);
        let deckLoaded = false;
        let loadedData = {};
        if (savedDeck) {
          try {
            const parsedDeck = JSON.parse(savedDeck);
            if (
              typeof parsedDeck === "object" &&
              parsedDeck !== null &&
              !Array.isArray(parsedDeck)
            ) {
              let isValid = true;
              const validatedDeck = {};
              for (const key in parsedDeck) {
                if (typeof key !== "string" || key.trim() === "") {
                  isValid = false;
                  break;
                }
                const entry = parsedDeck[key];
                if (
                  typeof entry !== "object" ||
                  entry === null ||
                  typeof entry.quantity !== "number" ||
                  !Number.isInteger(entry.quantity) ||
                  entry.quantity <= 0 ||
                  typeof entry.imageUrl !== "string" ||
                  (entry.hasOwnProperty("normalImageUrl") &&
                    typeof entry.normalImageUrl !== "string")
                ) {
                  if (
                    typeof entry.imageUrl === "string" &&
                    !entry.normalImageUrl
                  ) {
                    entry.normalImageUrl = entry.imageUrl;
                  } else {
                    isValid = false;
                    break;
                  }
                }
                validatedDeck[key] = {
                  quantity: entry.quantity,
                  imageUrl: entry.imageUrl,
                  normalImageUrl: entry.normalImageUrl || entry.imageUrl,
                };
              }
              if (isValid) {
                loadedData = validatedDeck;
                updateDeckActionStatus("Deck loaded successfully!");
                deckLoaded = true;
              } else {
                updateDeckActionStatus(
                  "Failed to load deck: Invalid data format found. Deck cleared."
                );
                console.warn(
                  "Invalid deck structure found in localStorage, deck reset.",
                  parsedDeck
                );
                loadedData = {};
              }
            } else {
              updateDeckActionStatus(
                "Failed to load deck: Invalid data type in storage. Deck cleared."
              );
              console.warn(
                "Invalid data type found in localStorage:",
                parsedDeck
              );
              loadedData = {};
            }
          } catch (error) {
            console.error("Error parsing saved deck:", error);
            updateDeckActionStatus(
              "Error loading deck: Could not parse saved data. Deck cleared."
            );
            loadedData = {};
          }
        } else {
          updateDeckActionStatus("No saved deck found.");
          loadedData = {};
        }
        currentDeck = loadedData;
        clearTestArea();
        renderDeck();
        drawHandButton.disabled =
          Object.values(currentDeck).reduce(
            (sum, card) => sum + card.quantity,
            0
          ) < 7;
        disableDrawNextButton();
        disableShuffleButton();
        disableSearchButton();
        disableScryButton();
        hideDeckSearchArea();
      }

      function drawTestHand() {
        clearTestArea();
        const deckArray = [];
        for (const cardName in currentDeck) {
          const cardInfo = currentDeck[cardName];
          if (cardInfo && cardInfo.quantity > 0) {
            for (let i = 0; i < cardInfo.quantity; i++)
              deckArray.push({
                name: cardName,
                imageUrl: cardInfo.imageUrl,
                normalImageUrl: cardInfo.normalImageUrl,
              });
          }
        }
        const deckSize = deckArray.length;
        if (deckSize < 7) {
          updateTestStatus(
            `Cannot draw hand: Deck only has ${deckSize} cards (needs at least 7).`
          );
          disableDrawNextButton();
          disableShuffleButton();
          disableSearchButton();
          disableScryButton();
          displayHand();
          displayBattlefield();
          displaySideZones();
          return;
        }
        shuffleArray(deckArray);
        const hand = deckArray.slice(0, 7);
        currentHand = hand.map((card) => ({
          handId: `h-${handCardIdCounter++}`,
          name: card.name,
          imageUrl: card.imageUrl,
          normalImageUrl: card.normalImageUrl,
        }));
        currentLibrary = deckArray.slice(7);
        displayHand();
        displayBattlefield();
        displaySideZones();
        updateTestStatus("Drew 7 cards.");
        enableDrawNextButton();
        enableShuffleButton();
        enableSearchButton();
        enableScryButton();
        hideDeckSearchArea();
        updateUntapAllButtonVisibility();
      }
      function drawNextCard() {
        if (currentLibrary.length === 0) {
          updateTestStatus("Cannot draw: Library is empty.");
          disableDrawNextButton();
          disableShuffleButton();
          disableSearchButton();
          disableScryButton();
          return;
        }
        const nextCard = currentLibrary.shift();
        currentHand.push({
          handId: `h-${handCardIdCounter++}`,
          name: nextCard.name,
          imageUrl: nextCard.imageUrl,
          normalImageUrl: nextCard.normalImageUrl,
        });
        displayHand();
        updateTestStatus(`Drew ${escapeHtml(nextCard.name)}.`);
        if (deckSearchArea.style.display === "block") {
          displayLibraryForSearch();
        }
        updateTestStatus();
      }
      function shuffleLibrary() {
        if (currentLibrary.length > 1) {
          shuffleArray(currentLibrary);
          updateTestStatus("Library shuffled.");
          if (deckSearchArea.style.display === "block") {
            displayLibraryForSearch();
          }
        } else {
          updateTestStatus("Cannot shuffle: Library has 1 or 0 cards.");
        }
      }
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }
      function enableDrawNextButton() {
        drawNextCardButton.disabled =
          currentLibrary.length === 0 || scryingState.active;
      }
      function disableDrawNextButton() {
        drawNextCardButton.disabled = true;
      }
      function enableShuffleButton() {
        shuffleDeckButton.disabled =
          currentLibrary.length <= 1 || scryingState.active;
      }
      function disableShuffleButton() {
        shuffleDeckButton.disabled = true;
      }
      function enableSearchButton() {
        searchDeckButton.disabled =
          currentLibrary.length === 0 || scryingState.active;
      }
      function disableSearchButton() {
        searchDeckButton.disabled = true;
      }
      function enableScryButton() {
        scryButton.disabled =
          currentLibrary.length === 0 || scryingState.active;
        scryCountInput.disabled =
          currentLibrary.length === 0 || scryingState.active;
        if (currentLibrary.length > 0)
          scryCountInput.max = currentLibrary.length;
        else scryCountInput.max = 1;
      }
      function disableScryButton() {
        scryButton.disabled = true;
        scryCountInput.disabled = true;
      }
      function clearTestArea() {
        currentHand = [];
        currentBattlefield = {};
        currentLibrary = [];
        currentGraveyard = [];
        currentExile = [];
        handCardIdCounter = 0;
        battlefieldCardIdCounter = 0;
        graveyardCardIdCounter = 0;
        exileCardIdCounter = 0;
        dragInfo = { cardId: null, offsetX: 0, offsetY: 0 };
        if (testHandContainer) testHandContainer.innerHTML = "";
        if (generalZone) {
          while (generalZone.children.length > 1) {
            generalZone.removeChild(generalZone.lastChild);
          }
        }
        if (graveyardZone) {
          while (graveyardZone.children.length > 1) {
            if (graveyardZone.lastChild.nodeName !== "H4") {
              graveyardZone.removeChild(graveyardZone.lastChild);
            } else {
              break;
            }
          }
        }
        if (exileZone) {
          while (exileZone.children.length > 1) {
            if (exileZone.lastChild.nodeName !== "H4") {
              exileZone.removeChild(exileZone.lastChild);
            } else {
              break;
            }
          }
        }
        if (testHandStatus) testHandStatus.textContent = "";
        if (graveyardCountSpan) graveyardCountSpan.textContent = "0";
        if (exileCountSpan) exileCountSpan.textContent = "0";
        disableDrawNextButton();
        disableShuffleButton();
        disableSearchButton();
        disableScryButton();
        hideDeckSearchArea();
        hideContextMenu();
        hideCardViewPopup();
        cancelScry();
        updateUntapAllButtonVisibility();
      }
      function handlePlayCardFromHand(event) {
        const cardDiv = event.currentTarget;
        const handId = cardDiv.dataset.handId;
        const cardIndex = currentHand.findIndex(
          (card) => card.handId === handId
        );
        if (cardIndex > -1) {
          const [cardToPlay] = currentHand.splice(cardIndex, 1);
          const battlefieldId = `bf-${battlefieldCardIdCounter++}`;
          const initialX = 10 + Math.floor(Math.random() * 10);
          const initialY = 10 + Math.floor(Math.random() * 10);
          currentBattlefield[battlefieldId] = {
            name: cardToPlay.name,
            imageUrl: cardToPlay.imageUrl,
            normalImageUrl: cardToPlay.normalImageUrl,
            zone: "general",
            isTapped: false,
            x: initialX,
            y: initialY,
          };
          displayHand();
          displayBattlefield();
          updateTestStatus(`Played ${escapeHtml(cardToPlay.name)}.`);
        }
      }

      function handleDragStart(event) {
        if (scryingState.active) {
          event.preventDefault();
          return;
        }
        const cardElement = event.target.closest(".battlefield-card");
        if (!cardElement || !cardElement.dataset.battlefieldId) return;
        const cardId = cardElement.dataset.battlefieldId;
        if (
          !currentBattlefield[cardId] ||
          currentBattlefield[cardId].zone !== "general"
        ) {
          event.preventDefault();
          return;
        }
        dragInfo.cardId = cardId;
        const rect = cardElement.getBoundingClientRect();

        const isTapped = currentBattlefield[cardId].isTapped;
        let clientX = event.clientX;
        let clientY = event.clientY;
        let cardLeft = rect.left;
        let cardTop = rect.top;

        if (isTapped) {
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const rotatedOffsetX = clientX - centerX;
          const rotatedOffsetY = clientY - centerY;
          const clickDist = Math.sqrt(
            rotatedOffsetX ** 2 + rotatedOffsetY ** 2
          );
          const clickAngle = Math.atan2(rotatedOffsetY, rotatedOffsetX);
          const originalAngle = clickAngle + Math.PI / 2;

          const originalOffsetX = clickDist * Math.cos(originalAngle);
          const originalOffsetY = clickDist * Math.sin(originalAngle);

          const untapppedWidth = rect.height;
          const untapppedHeight = rect.width;
          dragInfo.offsetX = untapppedWidth / 2 + originalOffsetX;
          dragInfo.offsetY = untapppedHeight / 2 + originalOffsetY;
        } else {
          dragInfo.offsetX = clientX - cardLeft;
          dragInfo.offsetY = clientY - cardTop;
        }

        event.dataTransfer.setData("text/plain", cardId);
        event.dataTransfer.effectAllowed = "move";
        setTimeout(() => {
          const img = cardElement.querySelector("img");
          if (img) img.classList.add("dragging");
        }, 0);
        event.stopPropagation();
        hideContextMenu();
        hideCardViewPopup();
      }
      function handleDragEnd(event) {
        const cardId = dragInfo.cardId;
        const cardElement = generalZone.querySelector(
          `[data-battlefield-id="${cardId}"]`
        );
        if (cardElement) {
          const img = cardElement.querySelector("img");
          if (img) img.classList.remove("dragging");
        }
        dragInfo.cardId = null;
        dragInfo.offsetX = 0;
        dragInfo.offsetY = 0;
      }
      function handleDragOver(event) {
        event.preventDefault();
        event.dataTransfer.dropEffect = "move";
      }
      function handleDrop(event) {
        event.preventDefault();
        event.stopPropagation();
        hideContextMenu();
        hideCardViewPopup();
        const targetZoneElement = event.currentTarget;
        const draggedCardId = dragInfo.cardId;
        if (!draggedCardId || !currentBattlefield[draggedCardId]) return;

        const cardData = { ...currentBattlefield[draggedCardId] };
        const dropZoneId = targetZoneElement.id;

        if (dropZoneId === "graveyardZone" || dropZoneId === "exileZone") {
          delete currentBattlefield[draggedCardId];
          const cardElement = generalZone.querySelector(
            `[data-battlefield-id="${draggedCardId}"]`
          );
          if (cardElement) cardElement.remove();

          if (dropZoneId === "graveyardZone") {
            delete cardData.x;
            delete cardData.y;
            delete cardData.zone;
            delete cardData.isTapped;
            cardData.gyId = `gy-${graveyardCardIdCounter++}`;
            currentGraveyard.push(cardData);
            updateTestStatus(
              `Moved ${escapeHtml(cardData.name)} to Graveyard.`
            );
          } else {
            delete cardData.x;
            delete cardData.y;
            delete cardData.zone;
            delete cardData.isTapped;
            cardData.exileId = `ex-${exileCardIdCounter++}`;
            currentExile.push(cardData);
            updateTestStatus(`Moved ${escapeHtml(cardData.name)} to Exile.`);
          }
          displaySideZones();
          updateUntapAllButtonVisibility();
        } else if (dropZoneId === "generalZone") {
          const zoneRect = targetZoneElement.getBoundingClientRect();
          let newX = event.clientX - zoneRect.left - dragInfo.offsetX;
          let newY = event.clientY - zoneRect.top - dragInfo.offsetY;

          const cardElement = generalZone.querySelector(
            `[data-battlefield-id="${draggedCardId}"]`
          );
          if (!cardElement) {
            console.error("Could not find dragged card element on drop.");
            displayBattlefield(); // Should redraw with correct state
            return;
          }

          const cardStyle = window.getComputedStyle(cardElement);
          const cardWidth = parseFloat(cardStyle.width);
          const cardHeight = parseFloat(cardStyle.height);

          const containerWidth = targetZoneElement.clientWidth;
          const containerHeight = targetZoneElement.clientHeight;

          newX = Math.max(0, Math.min(newX, containerWidth - cardWidth - 5));
          newY = Math.max(0, Math.min(newY, containerHeight - cardHeight - 5));
          newX = Math.max(0, newX);
          newY = Math.max(0, newY);

          currentBattlefield[draggedCardId].x = newX;
          currentBattlefield[draggedCardId].y = newY;
          currentBattlefield[draggedCardId].zone = "general";
          cardElement.style.left = `${newX}px`;
          cardElement.style.top = `${newY}px`;

          updateTestStatus(
            `Moved ${escapeHtml(cardData.name)} on battlefield.`
          );
          // No need to call displayBattlefield() here, just moved the element
        } else {
          console.warn("Drop occurred on unexpected element:", dropZoneId);
        }
      }

      function toggleDeckSearchArea() {
        if (scryingState.active) return;
        if (
          deckSearchArea.style.display === "none" ||
          !deckSearchArea.style.display
        ) {
          deckSearchArea.style.display = "block";
          displayLibraryForSearch();
          updateTestStatus("Viewing library...");
        } else {
          hideDeckSearchArea();
        }
      }
      function hideDeckSearchArea() {
        deckSearchArea.style.display = "none";
        deckSearchResults.innerHTML = "";
        updateTestStatus();
      }
      function displayLibraryForSearch() {
        deckSearchResults.innerHTML = "";
        if (currentLibrary.length === 0) {
          deckSearchResults.innerHTML = "<li>Library is empty.</li>";
          return;
        }
        const sortedLibrary = [...currentLibrary].sort((a, b) =>
          a.name.localeCompare(b.name)
        );
        sortedLibrary.forEach((card, displayIndex) => {
          const originalIndex = currentLibrary.findIndex((c) => c === card);
          if (originalIndex === -1 && currentLibrary.includes(card)) {
            console.warn(
              "Potential duplicate card issue in library search display:",
              card.name
            );
          }

          const li = document.createElement("li");
          const displayImageUrl = card.imageUrl || "";
          const normalImageUrl = card.normalImageUrl || displayImageUrl;
          li.innerHTML = `<img src="${escapeHtml(
            displayImageUrl
          )}" alt="${escapeHtml(card.name)}" title="${escapeHtml(
            card.name
          )}" loading="lazy" data-normal-src="${escapeHtml(normalImageUrl)}">`;

          li.dataset.libraryCardRef = displayIndex;
          li.dataset.cardname = card.name;
          li.dataset.imageurl = card.imageUrl;
          li.dataset.normalimageurl = card.normalImageUrl;

          deckSearchResults.appendChild(li);
        });
      }
      function handleDeckSearchResultClick(event) {
        const listItem = event.target.closest("li");
        if (!listItem || listItem.dataset.libraryCardRef === undefined) {
          return;
        }

        const cardNameToMove = listItem.dataset.cardname;
        const cardImageUrl = listItem.dataset.imageurl;
        const cardNormalUrl = listItem.dataset.normalimageurl;

        const cardIndexInLibrary = currentLibrary.findIndex(
          (c) =>
            c.name === cardNameToMove &&
            c.imageUrl === cardImageUrl &&
            c.normalImageUrl === cardNormalUrl
        );

        if (cardIndexInLibrary === -1) {
          console.error(
            "Could not find card in library to move:",
            cardNameToMove
          );
          updateTestStatus("Error moving card. Library may be out of sync.");
          displayLibraryForSearch();
          return;
        }

        const [cardToMove] = currentLibrary.splice(cardIndexInLibrary, 1);

        currentHand.push({
          handId: `h-${handCardIdCounter++}`,
          name: cardToMove.name,
          imageUrl: cardToMove.imageUrl,
          normalImageUrl: cardToMove.normalImageUrl,
        });
        displayHand();
        updateTestStatus(
          `Moved ${escapeHtml(cardToMove.name)} from library to hand.`
        );
        displayLibraryForSearch();
        if (currentLibrary.length === 0) {
          disableDrawNextButton();
          disableShuffleButton();
          disableSearchButton();
          disableScryButton();
        } else {
          enableDrawNextButton();
          enableShuffleButton();
          enableSearchButton();
          enableScryButton();
        }
      }

      function setTheme(themeName) {
        localStorage.setItem(THEME_STORAGE_KEY, themeName);
        document.body.setAttribute("data-theme", themeName);
        themeToggle.checked = themeName === "dark";
      }
      function toggleTheme() {
        if (themeToggle.checked) setTheme("dark");
        else setTheme("light");
      }
      function loadTheme() {
        const storedTheme = localStorage.getItem(THEME_STORAGE_KEY);
        const prefersDark =
          window.matchMedia &&
          window.matchMedia("(prefers-color-scheme: dark)").matches;
        if (storedTheme) setTheme(storedTheme);
        else if (prefersDark) setTheme("dark");
        else setTheme("light");
      }

      function showContextMenu(event, cardElement) {
        if (
          scryingState.active &&
          !cardElement.classList.contains("scry-card-item")
        ) {
          event.preventDefault();
          return;
        }
        event.preventDefault();
        hideContextMenu();
        hideCardViewPopup();

        let cardId = null;
        let sourceZone = null;
        let cardData = null;
        const cardRect = cardElement.getBoundingClientRect();

        if (cardElement.classList.contains("battlefield-card")) {
          sourceZone = "battlefield";
          cardId = cardElement.dataset.battlefieldId;
          if (currentBattlefield[cardId])
            cardData = { ...currentBattlefield[cardId] };
        } else if (cardElement.classList.contains("side-zone-card")) {
          const parentZone = cardElement.closest("#graveyardZone, #exileZone");
          if (parentZone && parentZone.id === "graveyardZone") {
            sourceZone = "graveyard";
            cardId = cardElement.dataset.gyId;
            const foundCard = currentGraveyard.find((c) => c.gyId === cardId);
            if (foundCard) cardData = { ...foundCard };
          } else if (parentZone && parentZone.id === "exileZone") {
            sourceZone = "exile";
            cardId = cardElement.dataset.exileId;
            const foundCard = currentExile.find((c) => c.exileId === cardId);
            if (foundCard) cardData = { ...foundCard };
          }
        } else if (cardElement.classList.contains("hand-card")) {
          sourceZone = "hand";
          cardId = cardElement.dataset.handId;
          const foundCard = currentHand.find((c) => c.handId === cardId);
          if (foundCard) cardData = { ...foundCard };
        } else if (cardElement.classList.contains("scry-card-item")) {
          sourceZone = "scry";
          cardId = cardElement.dataset.scryTempId;
          const foundCard = scryingState.cards.find(
            (c) => c.scryTempId === cardId
          );
          if (foundCard)
            cardData = {
              name: foundCard.name,
              imageUrl: foundCard.imageUrl,
              normalImageUrl: foundCard.normalImageUrl,
            };
        }

        if (!cardId || !sourceZone || !cardData) {
          console.error(
            "Could not identify card for context menu.",
            cardElement
          );
          return;
        }

        contextMenuTarget = { cardId, cardData, sourceZone };
        updateContextMenuItems(sourceZone, cardData);
        positionContextMenu(cardRect);
        cardContextMenu.style.display = "block";
        contextMenuVisible = true;
      }
      function hideContextMenu() {
        cardContextMenu.style.display = "none";
        contextMenuVisible = false;
        contextMenuTarget = { cardId: null, cardData: null, sourceZone: null };
      }
      function positionContextMenu(cardRect) {
        const menuWidth = cardContextMenu.offsetWidth;
        const menuHeight = cardContextMenu.offsetHeight;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const scrollX = window.scrollX;
        const scrollY = window.scrollY;
        const buffer = 5;

        let idealTop = cardRect.top + scrollY - menuHeight - buffer;
        let idealLeft = cardRect.left + scrollX;

        if (idealTop < scrollY + buffer) {
          idealTop = cardRect.bottom + scrollY + buffer;
        }

        if (idealLeft + menuWidth > viewportWidth + scrollX - buffer) {
          idealLeft = viewportWidth + scrollX - menuWidth - buffer;
        }

        idealLeft = Math.max(scrollX + buffer, idealLeft);

        if (idealTop + menuHeight > viewportHeight + scrollY - buffer) {
          if (idealTop > cardRect.bottom + scrollY + buffer) {
            idealTop = cardRect.top + scrollY - menuHeight - buffer;
          }
          if (idealTop + menuHeight > viewportHeight + scrollY - buffer) {
            idealTop = viewportHeight + scrollY - menuHeight - buffer;
          }
          idealTop = Math.max(scrollY + buffer, idealTop);
        }

        cardContextMenu.style.left = `${idealLeft}px`;
        cardContextMenu.style.top = `${idealTop}px`;
      }

      function updateContextMenuItems(sourceZone, cardData) {
        const items = cardContextMenu.querySelectorAll("li");
        items.forEach((item) => {
          const action = item.dataset.action;
          item.classList.remove("disabled", "hidden");

          if (sourceZone === "scry") {
            if (action !== "viewCard") {
              item.classList.add("hidden");
            }
          } else {
            if (
              (action === "toBattlefield" && sourceZone === "battlefield") ||
              (action === "toGraveyard" && sourceZone === "graveyard") ||
              (action === "toExile" && sourceZone === "exile") ||
              (action === "toHand" && sourceZone === "hand")
            ) {
              item.classList.add("disabled");
            }

            if (action === "toggleTap") {
              if (sourceZone === "battlefield") {
                item.textContent = cardData?.isTapped ? "Untap" : "Tap";
              } else {
                item.classList.add("hidden");
              }
            }

            if (
              (action === "toLibraryTop" || action === "toLibraryBottom") &&
              sourceZone === "library"
            ) {
              item.classList.add("disabled");
            }
          }
        });
      }

      function showCardViewPopup(imageUrl) {
        if (!imageUrl) {
          console.warn("Cannot show card view: No image URL provided.");
          return;
        }
        cardViewImage.src = imageUrl.replace("small", "normal");
        cardViewImage.onerror = () => {
          console.error("Failed to load image in card view popup:", imageUrl);
          cardViewImage.alt = "Image failed to load";
        };
        cardViewImage.alt = "Card Image";
        cardViewPopupOverlay.style.display = "flex";
      }

      function hideCardViewPopup() {
        cardViewPopupOverlay.style.display = "none";
        cardViewImage.src = "";
        cardViewImage.alt = "";
      }

      function handleContextMenuAction(event) {
        const targetLi = event.target.closest("li");
        if (
          !targetLi ||
          targetLi.classList.contains("disabled") ||
          targetLi.classList.contains("hidden") ||
          !contextMenuTarget.cardId
        ) {
          hideContextMenu();
          return;
        }

        const action = targetLi.dataset.action;
        const { cardId, cardData, sourceZone } = contextMenuTarget;

        if (!cardData) {
          console.error("Missing card data for context menu action.");
          hideContextMenu();
          return;
        }

        if (action === "viewCard") {
          const imageUrl = cardData.normalImageUrl || cardData.imageUrl;
          showCardViewPopup(imageUrl);
          hideContextMenu();
          return;
        }

        if (sourceZone === "scry") {
          hideContextMenu();
          return;
        }

        let cardRemoved = false;
        let performVisualUpdate = true;

        if (action === "toggleTap") {
          if (sourceZone === "battlefield" && currentBattlefield[cardId]) {
            const card = currentBattlefield[cardId];
            card.isTapped = !card.isTapped;
            const cardElement = generalZone.querySelector(
              `.battlefield-card[data-battlefield-id="${cardId}"]`
            );
            if (cardElement) {
              cardElement.classList.toggle("tapped", card.isTapped);
              if (!card.isTapped) {
                const zoneRect = generalZone.getBoundingClientRect();
                const cardRect = cardElement.getBoundingClientRect();
                const cardWidth = cardRect.width;
                const cardHeight = cardRect.height;
                let currentX = parseFloat(cardElement.style.left);
                let currentY = parseFloat(cardElement.style.top);
                let newX = Math.max(
                  0,
                  Math.min(currentX, generalZone.clientWidth - cardWidth - 5)
                );
                let newY = Math.max(
                  0,
                  Math.min(currentY, generalZone.clientHeight - cardHeight - 5)
                );

                if (newX !== currentX || newY !== currentY) {
                  cardElement.style.left = `${newX}px`;
                  cardElement.style.top = `${newY}px`;
                  card.x = newX;
                  card.y = newY;
                }
              }
            }
            updateTestStatus(
              `${card.isTapped ? "Tapped" : "Untapped"} ${escapeHtml(
                cardData.name
              )}.`
            );
            performVisualUpdate = false;
            updateUntapAllButtonVisibility();
          } else {
            console.error(
              "Cannot toggle tap: Card not found on battlefield or invalid zone."
            );
            performVisualUpdate = false;
          }
          hideContextMenu();
          return;
        }

        if (sourceZone === "battlefield") {
          if (currentBattlefield[cardId]) {
            delete currentBattlefield[cardId];
            cardRemoved = true;
          }
        } else if (sourceZone === "graveyard") {
          const index = currentGraveyard.findIndex((c) => c.gyId === cardId);
          if (index > -1) {
            currentGraveyard.splice(index, 1);
            cardRemoved = true;
          }
        } else if (sourceZone === "exile") {
          const index = currentExile.findIndex((c) => c.exileId === cardId);
          if (index > -1) {
            currentExile.splice(index, 1);
            cardRemoved = true;
          }
        } else if (sourceZone === "hand") {
          const index = currentHand.findIndex((c) => c.handId === cardId);
          if (index > -1) {
            currentHand.splice(index, 1);
            cardRemoved = true;
          }
        }

        if (!cardRemoved) {
          console.error(
            "Failed to remove card from source zone:",
            sourceZone,
            cardId
          );
          hideContextMenu();
          return;
        }

        const cleanCardData = {
          name: cardData.name,
          imageUrl: cardData.imageUrl,
          normalImageUrl: cardData.normalImageUrl,
        };
        let statusMsg = `Moved ${escapeHtml(cleanCardData.name)}`;
        let libraryAction = false;

        switch (action) {
          case "toHand":
            cleanCardData.handId = `h-${handCardIdCounter++}`;
            currentHand.push(cleanCardData);
            statusMsg += " to Hand.";
            break;
          case "toBattlefield":
            const bfId = `bf-${battlefieldCardIdCounter++}`;
            cleanCardData.x = 10 + Math.floor(Math.random() * 10);
            cleanCardData.y = 10 + Math.floor(Math.random() * 10);
            cleanCardData.zone = "general";
            cleanCardData.isTapped = false;
            currentBattlefield[bfId] = cleanCardData;
            statusMsg += " to Battlefield.";
            break;
          case "toGraveyard":
            cleanCardData.gyId = `gy-${graveyardCardIdCounter++}`;
            currentGraveyard.push(cleanCardData);
            statusMsg += " to Graveyard.";
            break;
          case "toExile":
            cleanCardData.exileId = `ex-${exileCardIdCounter++}`;
            currentExile.push(cleanCardData);
            statusMsg += " to Exile.";
            break;
          case "toLibraryTop":
            currentLibrary.unshift(cleanCardData);
            statusMsg += " to top of Library.";
            libraryAction = true;
            break;
          case "toLibraryBottom":
            currentLibrary.push(cleanCardData);
            statusMsg += " to bottom of Library.";
            libraryAction = true;
            break;
          default:
            console.warn("Unknown context menu action:", action);
            statusMsg = `Error processing action for ${escapeHtml(
              cleanCardData.name
            )}.`;
            performVisualUpdate = false;
            console.error(
              "Reverting action failed, card may be lost from test area."
            );
            break;
        }

        if (performVisualUpdate) {
          displayBattlefield();
          displaySideZones();
          displayHand();
          updateTestStatus(statusMsg);
        } else {
          updateTestStatus(); // Update status anyway to refresh counts etc.
        }

        if (libraryAction && deckSearchArea.style.display === "block") {
          displayLibraryForSearch();
        }
        if (libraryAction) {
          enableDrawNextButton();
          enableShuffleButton();
          enableSearchButton();
          enableScryButton();
        }
        updateUntapAllButtonVisibility(); // Check button visibility after any move
        hideContextMenu();
      }

      function handleScry() {
        if (scryingState.active) return;
        const count = parseInt(scryCountInput.value, 10);
        if (isNaN(count) || count <= 0) {
          updateTestStatus("Invalid scry amount.");
          return;
        }
        const actualCount = Math.min(count, currentLibrary.length);
        if (actualCount === 0) {
          updateTestStatus("Library is empty, cannot scry.");
          return;
        }
        scryingState.active = true;
        scryingState.cards = [];
        scryingState.expectedCount = actualCount;
        scryingState.resolvedCount = 0;
        scryingState.toBottom = [];

        for (let i = 0; i < actualCount; i++) {
          const card = currentLibrary.shift();
          if (card) {
            card.scryTempId = `scry-${i}`;
            scryingState.cards.push(card);
          }
        }
        disableDrawNextButton();
        disableShuffleButton();
        disableSearchButton();
        disableScryButton();
        untapAllButton.disabled = true; // Disable untap during scry
        displayScryModal(actualCount);
        updateTestStatus(
          `Scrying ${actualCount} cards... Choose Top or Bottom for each.`
        );
      }

      function displayScryModal(count) {
        scryModalTitle.textContent = `Scry ${count}`;
        scryCardContainer.innerHTML = "";

        scryingState.cards.forEach((card) => {
          const cardDiv = document.createElement("div");
          cardDiv.classList.add("scry-card-item");
          cardDiv.dataset.scryTempId = card.scryTempId;

          const img = document.createElement("img");
          img.src = escapeHtml(card.imageUrl || "");
          img.alt = escapeHtml(card.name);
          img.title = escapeHtml(card.name);
          img.dataset.normalSrc = escapeHtml(
            card.normalImageUrl || card.imageUrl || ""
          );
          cardDiv.appendChild(img);

          const buttonDiv = document.createElement("div");
          buttonDiv.classList.add("scry-choice-buttons");

          const topButton = document.createElement("button");
          topButton.textContent = "Top";
          topButton.dataset.choice = "top";
          topButton.addEventListener("click", handleScryChoice);

          const bottomButton = document.createElement("button");
          bottomButton.textContent = "Bottom";
          bottomButton.dataset.choice = "bottom";
          bottomButton.addEventListener("click", handleScryChoice);

          buttonDiv.appendChild(topButton);
          buttonDiv.appendChild(bottomButton);
          cardDiv.appendChild(buttonDiv);

          cardDiv.addEventListener("contextmenu", (event) =>
            showContextMenu(event, cardDiv)
          );

          scryCardContainer.appendChild(cardDiv);
        });

        scryOverlay.style.display = "flex";
      }

      function handleScryChoice(event) {
        if (!scryingState.active) return;
        hideContextMenu();

        const button = event.target;
        const choice = button.dataset.choice;
        const cardItem = button.closest(".scry-card-item");
        const scryTempId = cardItem.dataset.scryTempId;

        const cardIndex = scryingState.cards.findIndex(
          (c) => c.scryTempId === scryTempId
        );
        if (cardIndex === -1) {
          console.error("Could not find scry card data for ID:", scryTempId);
          return;
        }

        const [cardData] = scryingState.cards.splice(cardIndex, 1);
        delete cardData.scryTempId;

        let actionMsg = "";
        if (choice === "top") {
          currentLibrary.unshift(cardData);
          actionMsg = `Keeping ${escapeHtml(cardData.name)} on top.`;
        } else {
          scryingState.toBottom.push(cardData);
          actionMsg = `Moving ${escapeHtml(cardData.name)} to bottom.`;
        }

        cardItem.remove();
        updateTestStatus(actionMsg);

        scryingState.resolvedCount++;

        if (scryingState.resolvedCount === scryingState.expectedCount) {
          currentLibrary.push(...scryingState.toBottom);
          scryingState.toBottom = [];
          endScrySession();
        }
      }

      function endScrySession() {
        const wasActive = scryingState.active;
        hideContextMenu();
        scryingState.active = false;
        scryingState.cards = [];
        scryingState.toBottom = [];
        scryingState.expectedCount = 0;
        scryingState.resolvedCount = 0;
        scryOverlay.style.display = "none";
        scryCardContainer.innerHTML = "";
        enableDrawNextButton();
        enableShuffleButton();
        enableSearchButton();
        enableScryButton();
        untapAllButton.disabled = false; // Re-enable untap button

        if (wasActive) {
          let currentStatus = testHandStatus.textContent || "";
          currentStatus = currentStatus
            .replace(/Scrying.*Choose.*|Keeping.*top\.|Moving.*bottom\./g, "")
            .trim();
          updateTestStatus(currentStatus + " Scry finished.");
        } else {
          updateTestStatus();
        }

        if (deckSearchArea.style.display === "block") {
          displayLibraryForSearch();
        }
      }

      function cancelScry() {
        if (scryingState.active) {
          hideContextMenu();
          const cardsToReturn = [
            ...scryingState.cards,
            ...scryingState.toBottom,
          ];
          cardsToReturn.forEach((card) => delete card.scryTempId);
          currentLibrary.unshift(...cardsToReturn);

          updateTestStatus("Scry cancelled. Cards returned to library.");
          endScrySession();
        }
      }

      searchInput.addEventListener("input", (event) => {
        debouncedLiveSearch(event.target.value.trim());
      });
      searchResults.addEventListener("click", (event) => {
        const li = event.target.closest("li");
        if (li && li.dataset.cardname)
          addCardToDeck(
            li.dataset.cardname,
            li.dataset.imageurl,
            li.dataset.normalimageurl
          );
      });
      document.addEventListener("click", (event) => {
        const searchSection = event.target.closest(".search-section");
        const resultsList = event.target.closest("#searchResults");
        if (!searchSection && !resultsList) {
          searchResults.innerHTML = "";
          searchResults.style.display = "none";
        }

        if (contextMenuVisible && !cardContextMenu.contains(event.target)) {
          const targetCard = event.target.closest(
            ".battlefield-card, .side-zone-card, .hand-card, .scry-card-item"
          );
          if (!targetCard) {
            hideContextMenu();
          }
        }

        const deckSearchDiv = event.target.closest("#deckSearchArea");
        const searchButton = event.target.closest("#searchDeckButton");
        const closeSearchButton = event.target.closest(
          "#closeSearchAreaButton"
        );

        if (
          deckSearchArea.style.display === "block" &&
          !deckSearchDiv &&
          !searchButton &&
          !closeSearchButton
        ) {
          hideDeckSearchArea();
        }

        if (event.target === cardViewPopupOverlay) {
          hideCardViewPopup();
        }
      });
      searchInput.addEventListener("keypress", (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          const firstResult = searchResults.querySelector("li");
          if (firstResult && firstResult.dataset.cardname)
            addCardToDeck(
              firstResult.dataset.cardname,
              firstResult.dataset.imageurl,
              firstResult.dataset.normalimageurl
            );
        }
      });
      deckList.addEventListener("click", (event) => {
        if (event.target.classList.contains("delete-card-btn")) {
          const cardName = event.target.getAttribute("data-cardname");
          if (cardName) deleteCardFromDeck(cardName);
        }
      });
      deckList.addEventListener("change", (event) => {
        if (event.target.classList.contains("quantity-input")) {
          const cardName = event.target.getAttribute("data-cardname");
          if (cardName) updateCardQuantity(cardName, event.target.value);
        }
      });
      saveDeckButton.addEventListener("click", saveDeck);
      loadDeckButton.addEventListener("click", loadDeck);
      clearDeckButton.addEventListener("click", clearDeck);
      drawHandButton.addEventListener("click", drawTestHand);
      drawNextCardButton.addEventListener("click", drawNextCard);
      shuffleDeckButton.addEventListener("click", shuffleLibrary);
      searchDeckButton.addEventListener("click", toggleDeckSearchArea);
      closeSearchAreaButton.addEventListener("click", hideDeckSearchArea);
      scryButton.addEventListener("click", handleScry);
      deckSearchResults.addEventListener("click", handleDeckSearchResultClick);
      [generalZone, graveyardZone, exileZone].forEach((zone) => {
        zone.addEventListener("dragover", handleDragOver);
        zone.addEventListener("drop", handleDrop);
      });

      untapAllButton.addEventListener("click", () => {
        let untappedCount = 0;
        for (const id in currentBattlefield) {
          if (
            currentBattlefield[id].zone === "general" &&
            currentBattlefield[id].isTapped
          ) {
            currentBattlefield[id].isTapped = false;
            untappedCount++;
          }
        }
        if (untappedCount > 0) {
          displayBattlefield(); // Re-render the battlefield with untapped cards
          updateTestStatus(`Untapped ${untappedCount} card(s).`);
        }
        updateUntapAllButtonVisibility(); // This will hide the button
      });

      themeToggle.addEventListener("change", toggleTheme);

      document.addEventListener("contextmenu", (event) => {
        if (contextMenuVisible) {
          hideContextMenu();
        }

        const targetCard = event.target.closest(
          ".battlefield-card, .side-zone-card, .hand-card, .scry-card-item"
        );

        if (targetCard) {
          event.preventDefault();
          showContextMenu(event, targetCard);
        }
      });

      cardContextMenu.addEventListener("click", handleContextMenuAction);
      closeCardViewPopupButton.addEventListener("click", hideCardViewPopup);

      window.addEventListener(
        "scroll",
        () => {
          hideContextMenu();
          hideCardViewPopup();
        },
        true
      );
      window.addEventListener(
        "resize",
        () => {
          hideContextMenu();
          hideCardViewPopup();
        },
        true
      );

      document.addEventListener("DOMContentLoaded", () => {
        loadTheme();
        loadDeck();
      });
    </script>
  </body>
</html>
